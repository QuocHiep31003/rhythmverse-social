import { useState, useEffect, useRef, useCallback } from "react";
import type { DragEvent, MouseEvent } from "react";
import { useLocation } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import {
  Play,
  Pause,
  SkipBack,
  SkipForward,
  Volume2,
  VolumeX,
  Heart,
  Share2,
  Shuffle,
  Repeat,
  Music,
  Users,
  ListPlus,
  Copy,
  X,
  Menu,
  MoreHorizontal,
  GripVertical,
  Trash2,
  ChevronsDown,
} from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn, handleImageError, toSeconds } from "@/lib/utils";
import { useMusic } from "@/contexts/MusicContext";
import { toast } from "@/hooks/use-toast";
import { listeningHistoryApi } from "@/services/api/listeningHistoryApi";
import { lyricsApi } from "@/services/api/lyricsApi";
import { songsApi } from "@/services/api/songApi";
import { getAuthToken, forceRefreshAccessToken } from "@/services/api";
import { mapToPlayerSong } from "@/lib/utils";
import { Switch } from "@/components/ui/switch";
import Hls from "hls.js";
import { AddToPlaylistDialog } from "@/components/playlist/AddToPlaylistDialog";
import ShareButton from "@/components/ShareButton";

interface LyricLine {
  time: number;
  text: string;
}

const MusicPlayer = () => {
  const location = useLocation();
  const {
    currentSong,
    isPlaying,
    togglePlay,
    playNext,
    playPrevious,
    isShuffled,
    repeatMode,
    toggleShuffle,
    setRepeatMode,
    queue,
    playSong,
    setQueue,
    addToQueue,
    removeFromQueue,
    moveQueueItem,
    resetPlayer,
    isAuthenticated,
    activeDeviceId,
    activeDeviceName,
    position,
    duration,
    setDuration,
    updatePosition,
    updateDuration,
    requestPlaybackControl,
    currentDeviceId,
  } = useMusic();
  const audioRef = useRef<HTMLAudioElement>(null);
  const lyricsRef = useRef<HTMLDivElement>(null);
  const currentLyricRef = useRef<HTMLParagraphElement>(null);
  const [volume, setVolume] = useState([75]);
  const [progress, setProgress] = useState([0]);
  const [isMuted, setIsMuted] = useState(false);
  const [isLiked, setIsLiked] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);
  const [showLyrics, setShowLyrics] = useState(false);
  const [lyrics, setLyrics] = useState<LyricLine[]>([]);
  const [currentLyricIndex, setCurrentLyricIndex] = useState(0);
  const [audioDuration, setAudioDuration] = useState(0); // Local audio duration in seconds
  const [currentTime, setCurrentTime] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [showPlaylist, setShowPlaylist] = useState(false);
  const [suggestedSongs, setSuggestedSongs] = useState<typeof queue>([]);
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(false);
  const [autoPlaySuggestions, setAutoPlaySuggestions] = useState(true);
  const showQueueScrollHint = queue.length > 4;
  const loadedSuggestionsForSongId = useRef<string | number | null>(null);
  const [addToPlaylistOpen, setAddToPlaylistOpen] = useState(false);
  const [shareSong, setShareSong] = useState<{ id: string | number; title: string; url: string } | null>(null);
  const [playlistTab, setPlaylistTab] = useState<"queue" | "suggested">("queue");
  const [draggingSongId, setDraggingSongId] = useState<string | null>(null);
  const isPlayingRef = useRef(isPlaying);
  const currentSongRef = useRef<typeof currentSong>(null);
  const cleanupCallbacks = useRef<(() => void)[]>([]);
  const hlsInstanceRef = useRef<Hls | null>(null);
  const hasTriggeredEndedRef = useRef(false);
  const listenedSecondsRef = useRef(0);
  const hasReportedSessionRef = useRef(false);
  const streamAuthRetryCountRef = useRef(0);
  const streamRetryUrlRef = useRef("");
  const [showDeviceSelector, setShowDeviceSelector] = useState(false);
  // currentDeviceId Ä‘Ã£ Ä‘Æ°á»£c láº¥y tá»« useMusic() á»Ÿ trÃªn
  const isThisDeviceActive = activeDeviceId === null || activeDeviceId === currentDeviceId;

  useEffect(() => {
    isPlayingRef.current = isPlaying;
  }, [isPlaying]);
  
  // Detect khi tab chÃ­nh (active device) Ä‘Ã³ng vÃ  pause táº¥t cáº£
  useEffect(() => {
    if (typeof window === 'undefined') return;
    
    // Chá»‰ xá»­ lÃ½ náº¿u device nÃ y lÃ  active device
    if (!isThisDeviceActive) return;
    
    const handlePageHide = async (e: PageTransitionEvent) => {
      // Khi tab bá»‹ áº©n/Ä‘Ã³ng, pause náº¿u Ä‘ang phÃ¡t
      // pagehide Ä‘Æ°á»£c gá»i trÆ°á»›c khi beforeunload, cÃ³ nhiá»u thá»i gian hÆ¡n Ä‘á»ƒ gá»­i request
      if (isPlaying && audioRef.current && !audioRef.current.paused) {
        console.log('[MusicPlayer] âš ï¸ Tab chÃ­nh Ä‘ang Ä‘Ã³ng, pausing playback...');
        // Gá»­i signal pause lÃªn backend
        try {
          const { getAuthToken, API_BASE_URL } = await import('@/services/api/config');
          const token = getAuthToken();
          if (token && navigator.sendBeacon) {
            const url = `${API_BASE_URL}/playback/toggle?deviceId=${encodeURIComponent(currentDeviceId)}`;
            // DÃ¹ng sendBeacon Ä‘á»ƒ Ä‘áº£m báº£o request Ä‘Æ°á»£c gá»­i ngay cáº£ khi tab Ä‘ang Ä‘Ã³ng
            const blob = new Blob([JSON.stringify({})], { type: 'application/json' });
            navigator.sendBeacon(url, blob);
          }
        } catch (err) {
          console.error('[MusicPlayer] Failed to send pause beacon:', err);
        }
        
        // CÅ©ng thá»­ gá»i togglePlay bÃ¬nh thÆ°á»ng (cÃ³ thá»ƒ khÃ´ng ká»‹p nhÆ°ng váº«n thá»­)
        togglePlay().catch(err => {
          console.error('[MusicPlayer] Failed to pause on page hide:', err);
        });
      }
    };
    
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      // Fallback: náº¿u pagehide khÃ´ng ká»‹p, thá»­ pause á»Ÿ Ä‘Ã¢y
      // beforeunload khÃ´ng thá»ƒ dÃ¹ng async, chá»‰ cÃ³ thá»ƒ dÃ¹ng sendBeacon
      if (isPlaying && audioRef.current && !audioRef.current.paused) {
        console.log('[MusicPlayer] âš ï¸ beforeunload: Tab chÃ­nh Ä‘ang Ä‘Ã³ng, attempting to pause...');
        try {
          // Import sync Ä‘á»ƒ dÃ¹ng trong beforeunload
          import('@/services/api/config').then(({ getAuthToken, API_BASE_URL }) => {
            const token = getAuthToken();
            if (token && navigator.sendBeacon) {
              const url = `${API_BASE_URL}/playback/toggle?deviceId=${encodeURIComponent(currentDeviceId)}`;
              const blob = new Blob([JSON.stringify({})], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
            }
          }).catch(() => {
            // Ignore errors in beforeunload
          });
        } catch (err) {
          // Ignore errors in beforeunload
        }
      }
    };
    
    const handleVisibilityChange = () => {
      // Khi tab bá»‹ áº©n (khÃ´ng pháº£i Ä‘Ã³ng), váº«n cÃ³ thá»ƒ phÃ¡t nhÆ°ng sáº½ pause náº¿u disconnect
      if (document.hidden && isPlaying && audioRef.current && !audioRef.current.paused) {
        console.log('[MusicPlayer] Tab bá»‹ áº©n nhÆ°ng váº«n phÃ¡t (background playback)');
        // KhÃ´ng pause ngay, nhÆ°ng sáº½ pause náº¿u disconnect (detect bá»Ÿi timestamp)
      }
    };
    
    // pagehide Ä‘Æ°á»£c gá»i trÆ°á»›c, cÃ³ nhiá»u thá»i gian hÆ¡n
    window.addEventListener('pagehide', handlePageHide);
    window.addEventListener('beforeunload', handleBeforeUnload);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    
    return () => {
      window.removeEventListener('pagehide', handlePageHide);
      window.removeEventListener('beforeunload', handleBeforeUnload);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [isThisDeviceActive, isPlaying, togglePlay, currentDeviceId]);

  useEffect(() => {
    if (repeatMode !== "off" && autoPlaySuggestions) {
      setAutoPlaySuggestions(false);
      toast({
        title: "ÄÃ£ táº¯t gá»£i Ã½ tá»± Ä‘á»™ng",
        description: "Gá»£i Ã½ chá»‰ hoáº¡t Ä‘á»™ng khi cháº¿ Ä‘á»™ láº·p Ä‘ang táº¯t.",
        variant: "warning",
      });
    }
  }, [repeatMode, autoPlaySuggestions]);

  const resetListeningSessionTracking = useCallback(() => {
    listenedSecondsRef.current = 0;
    hasReportedSessionRef.current = false;
  }, []);

  const finalizeListeningSession = useCallback((reason: string) => {
    const song = currentSongRef.current;
    if (!song) {
      resetListeningSessionTracking();
      return;
    }

    if (hasReportedSessionRef.current) {
      resetListeningSessionTracking();
      return;
    }

    const userId = 0;
    const songIdForApi = isNaN(Number(song.id)) ? song.id : Number(song.id);
    const accumulatedSeconds = Math.floor(listenedSecondsRef.current);
    if (accumulatedSeconds <= 0) {
      resetListeningSessionTracking();
      return;
    }

    const audio = audioRef.current;
    const audioDurationSeconds =
      audio && !isNaN(audio.duration) && audio.duration > 0 ? Math.round(audio.duration) : null;
    const normalizedSongDuration = audioDurationSeconds ?? Math.max(1, accumulatedSeconds);
    const effectiveDuration = Math.min(Math.max(1, accumulatedSeconds), normalizedSongDuration);

    console.log(
      `Finalizing listening session (${reason}) â†’ userId=${userId}, songId=${songIdForApi}, duration=${effectiveDuration}s/${normalizedSongDuration}s`,
    );
    hasReportedSessionRef.current = true;

    listeningHistoryApi
      .recordListen({
        userId,
        songId: songIdForApi,
        listenedDuration: effectiveDuration,
        songDuration: normalizedSongDuration,
      })
      .then(() => {
        console.log('Listening session recorded successfully');
      })
      .catch((error) => {
        console.error('Failed to record listening session:', error);
        hasReportedSessionRef.current = false;
      })
      .finally(() => {
        resetListeningSessionTracking();
      });
  }, [resetListeningSessionTracking]);

  useEffect(() => {
    if (location.pathname === "/login") {
      finalizeListeningSession("login-navigation");
      resetListeningSessionTracking();
      resetPlayer();
    }
  }, [location.pathname, finalizeListeningSession, resetListeningSessionTracking, resetPlayer]);

  useEffect(() => {
    currentSongRef.current = currentSong;
  }, [currentSong]);

  const formatTime = (value: unknown) => {
    const totalSeconds = toSeconds(value);
    const mins = Math.floor(totalSeconds / 60);
    const secs = Math.floor(totalSeconds % 60);
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };

  const getCurrentTime = () => {
    if (!audioRef.current) return 0;
    return audioRef.current.currentTime;
  };

  // Load lyrics when song changes
  useEffect(() => {
    if (!currentSong) {
      setLyrics([]);
      setCurrentLyricIndex(0);
      return;
    }

    const loadLyrics = async () => {
      try {
        const loadedLyrics = await lyricsApi.getLyrics(currentSong.id);
        setLyrics(loadedLyrics);
        setCurrentLyricIndex(0);
      } catch (error) {
        console.error("Failed to load lyrics:", error);
        setLyrics([{ time: 0, text: "â™ª No lyrics available..." }]);
      }
    };

    loadLyrics();
  }, [currentSong]);

  // Update current lyric based on playback time
  useEffect(() => {
    if (lyrics.length === 0) return;

    const interval = setInterval(() => {
      const currentTime = getCurrentTime();
      let newIndex = 0;

      for (let i = lyrics.length - 1; i >= 0; i--) {
        if (currentTime >= lyrics[i].time) {
          newIndex = i;
          break;
        }
      }

      if (newIndex !== currentLyricIndex) {
        setCurrentLyricIndex(newIndex);
      }
    }, 100);

    return () => clearInterval(interval);
  }, [lyrics, currentLyricIndex]);

  // Auto-scroll to current lyric
  useEffect(() => {
    if (currentLyricRef.current && lyricsRef.current) {
      currentLyricRef.current.scrollIntoView({
        behavior: "smooth",
        block: "center",
      });
    }
  }, [currentLyricIndex]);

  // Handle clicking on a lyric to jump to that time
  const handleLyricClick = (time: number) => {
    if (audioRef.current && !isNaN(audioRef.current.duration)) {
      audioRef.current.currentTime = time;
      setProgress([(time / audioRef.current.duration) * 100]);
    }
  };

  const handleToggleAutoSuggestions = (checked: boolean) => {
    if (checked && repeatMode !== "off") {
      toast({
        title: "KhÃ´ng thá»ƒ báº­t gá»£i Ã½",
        description: "Táº¯t cháº¿ Ä‘á»™ láº·p Ä‘á»ƒ sá»­ dá»¥ng gá»£i Ã½ tá»± Ä‘á»™ng.",
        variant: "warning",
      });
      return;
    }
    setAutoPlaySuggestions(checked);
    toast({
      title: checked ? "ÄÃ£ báº­t gá»£i Ã½ tá»± Ä‘á»™ng" : "ÄÃ£ táº¯t gá»£i Ã½ tá»± Ä‘á»™ng",
      description: checked
        ? "Khi háº¿t danh sÃ¡ch phÃ¡t sáº½ phÃ¡t tiáº¿p cÃ¡c gá»£i Ã½"
        : "Khi háº¿t danh sÃ¡ch phÃ¡t sáº½ dá»«ng láº¡i",
      duration: 2500,
      variant: checked ? "success" : "info",
    });
  };

  const startSuggestionsPlayback = useCallback(() => {
    if (repeatMode !== "off") {
      console.warn("Auto suggestions require repeat off");
      return false;
    }
    if (!autoPlaySuggestions) {
      console.warn("Auto suggestions disabled");
      return false;
    }
    if (suggestedSongs.length === 0) {
      console.warn("No suggested songs available");
      return false;
    }
    const nextSong = suggestedSongs[0];
    console.log("ðŸŽ§ Adding suggested song to queue:", nextSong.songName || nextSong.name);
    addToQueue(nextSong);
    playSong(nextSong);
    return true;
  }, [addToQueue, autoPlaySuggestions, playSong, repeatMode, suggestedSongs]);

  const hasNextQueueSong = useCallback(() => {
    if (queue.length === 0) {
      return false;
    }
    if (!currentSong) {
      return queue.length > 0;
    }
    const currentIndex = queue.findIndex((s) => s.id === currentSong.id);
    if (currentIndex === -1) {
      return queue.length > 0;
    }
    if (currentIndex < queue.length - 1) {
      return true;
    }
    return repeatMode === "all" && queue.length > 0;
  }, [currentSong, queue, repeatMode]);

  const finalizeQueueAfterPlayback = useCallback(
    (finishedSongId?: string | number) => {
      if (!finishedSongId) return;
      if (repeatMode === "off") {
        removeFromQueue(finishedSongId);
      } else if (repeatMode === "all") {
        const idx = queue.findIndex((s) => String(s.id) === String(finishedSongId));
        if (idx !== -1) {
          moveQueueItem(idx, queue.length - 1);
        }
      }
    },
    [moveQueueItem, queue, removeFromQueue, repeatMode],
  );

  const handleNextClick = () => {
    if (!hasNextQueueSong()) {
      const finishedId = currentSong?.id;
      finalizeQueueAfterPlayback(finishedId);
      if (!startSuggestionsPlayback()) {
        console.warn("No more songs to play");
      }
      return;
    }
    const finishedId = currentSong?.id;
    playNext();
    finalizeQueueAfterPlayback(finishedId);
  };

  const handleRemoveSong = (event: MouseEvent<HTMLButtonElement>, songId: string | number) => {
    event.stopPropagation();
    removeFromQueue(songId);
  };

  const handleDragStart = (event: DragEvent<HTMLDivElement>, songId: string | number) => {
    event.stopPropagation();
    setDraggingSongId(String(songId));
    event.dataTransfer.effectAllowed = "move";
    event.dataTransfer.setData("text/plain", String(songId));
  };

  const handleDragOver = (event: DragEvent<HTMLDivElement>, songId: string | number) => {
    if (!draggingSongId) return;
    event.preventDefault();
    event.stopPropagation();
    if (draggingSongId === String(songId)) return;
    event.dataTransfer.dropEffect = "move";
  };

  const handleDrop = (event: DragEvent<HTMLDivElement>, songId: string | number) => {
    if (!draggingSongId) return;
    event.preventDefault();
    event.stopPropagation();
    const sourceIndex = queue.findIndex((s) => String(s.id) === draggingSongId);
    const targetIndex = queue.findIndex((s) => String(s.id) === String(songId));
    if (sourceIndex !== -1 && targetIndex !== -1 && sourceIndex !== targetIndex) {
      moveQueueItem(sourceIndex, targetIndex);
    }
    setDraggingSongId(null);
  };

  const handleDropToEnd = (event: DragEvent<HTMLDivElement>) => {
    if (!draggingSongId) return;
    event.preventDefault();
    event.stopPropagation();
    const sourceIndex = queue.findIndex((s) => String(s.id) === draggingSongId);
    if (sourceIndex !== -1 && sourceIndex !== queue.length - 1) {
      moveQueueItem(sourceIndex, queue.length - 1);
    }
    setDraggingSongId(null);
  };

  const handleDragEnd = () => setDraggingSongId(null);

  // Load new song - CHá»ˆ active device má»›i load HLS file
  // Non-active devices chá»‰ sync UI, khÃ´ng load file
  // QUAN TRá»ŒNG: CÅ©ng load khi device nÃ y trá»Ÿ thÃ nh active device (isThisDeviceActive thay Ä‘á»•i tá»« false -> true)
  useEffect(() => {
    finalizeListeningSession("song-change");
    resetListeningSessionTracking();

    if (!audioRef.current || !currentSong) return;

    const audio = audioRef.current;
    
    // QUAN TRá»ŒNG: Device phá»¥ cÅ©ng load HLS file (preload) Ä‘á»ƒ khi trá»Ÿ thÃ nh chÃ­nh cÃ³ thá»ƒ phÃ¡t ngay
    // NhÆ°ng device phá»¥ khÃ´ng play audio, chá»‰ load Ä‘á»ƒ sáºµn sÃ ng
    if (!isThisDeviceActive) {
      console.log('[MusicPlayer] âš ï¸ Device nÃ y khÃ´ng pháº£i active device, nhÆ°ng sáº½ preload HLS file Ä‘á»ƒ sáºµn sÃ ng...');
      // Device phá»¥: pause audio nhÆ°ng váº«n load file Ä‘á»ƒ preload
      audio.pause();
      // KHÃ”NG clear src náº¿u Ä‘Ã£ cÃ³ src Ä‘Ãºng vá»›i bÃ i hiá»‡n táº¡i (Ä‘á»ƒ giá»¯ preload)
      if (audio.src && audio.src.includes(currentSong.id)) {
        console.log('[MusicPlayer] âœ… Device phá»¥ Ä‘Ã£ cÃ³ file preloaded, giá»¯ nguyÃªn Ä‘á»ƒ sáºµn sÃ ng');
        // Äáº£m báº£o audio khÃ´ng play (chá»‰ preload)
        if (!audio.paused) {
          audio.pause();
        }
        return; // ÄÃ£ cÃ³ file preloaded
      }
      // Náº¿u chÆ°a cÃ³ file hoáº·c file khÃ¡c, sáº½ load á»Ÿ dÆ°á»›i (khÃ´ng return)
      console.log('[MusicPlayer] ðŸ”„ Device phá»¥ chÆ°a cÃ³ file, sáº½ preload...');
    }
    
    // QUAN TRá»ŒNG: Náº¿u device nÃ y vá»«a trá»Ÿ thÃ nh active device vÃ  Ä‘Ã£ cÃ³ src, khÃ´ng cáº§n load láº¡i
    // Chá»‰ load náº¿u chÆ°a cÃ³ src hoáº·c src khÃ¡c vá»›i bÃ i hiá»‡n táº¡i
    if (audio.src && audio.src.includes(currentSong.id)) {
      console.log('[MusicPlayer] âœ… Device nÃ y vá»«a trá»Ÿ thÃ nh active device, Ä‘Ã£ cÃ³ HLS file, khÃ´ng cáº§n load láº¡i');
      // Äáº£m báº£o audio ready vÃ  play náº¿u isPlaying = true
      if (isPlaying && audio.paused) {
        if (audio.readyState >= 2) {
          console.log('[MusicPlayer] âœ… Audio ready, playing immediately...');
          audio.play().catch(err => {
            console.error("Play error:", err);
          });
        } else {
          // Äá»£i audio ready
          const onCanPlay = () => {
            if (isPlaying && audio.paused) {
              console.log('[MusicPlayer] âœ… Audio can play, playing now...');
              audio.play().catch(err => {
                console.error("Play error:", err);
              });
            }
            audio.removeEventListener('canplay', onCanPlay);
          };
          audio.addEventListener('canplay', onCanPlay);
        }
      }
      return; // ÄÃ£ cÃ³ file, khÃ´ng cáº§n load láº¡i
    }

    console.log('[MusicPlayer] âœ… Device nÃ y lÃ  active device, loading HLS file...');

    streamAuthRetryCountRef.current = 0;

    // Immediately pause and reset current playback
    audio.pause();
    audio.currentTime = 0;
    setIsLoading(true);

    // Reset all tracking states for new song
    setCurrentTime(0);
    setProgress([0]);
    setCurrentLyricIndex(0);
    setDuration(0);

    cleanupCallbacks.current = [];
    
    // Reset flag khi load bÃ i má»›i
    hasTriggeredEndedRef.current = false;
    hlsInstanceRef.current = null;

    let hls: Hls | null = null;
    let safariMetadataListener: (() => void) | null = null;
    let loadErrorTimeout: ReturnType<typeof setTimeout> | null = null;

    const refreshTokenAndRetryStream = async () => {
      try {
        setIsLoading(true);
        const newToken = await forceRefreshAccessToken();
        if (!newToken) {
          throw new Error("KhÃ´ng thá»ƒ lÃ m má»›i token");
        }

        console.log("[MusicPlayer] Access token refreshed during playback, retrying HLS load");
        if (streamRetryUrlRef.current) {
          try {
            hlsInstanceRef.current?.stopLoad();
          } catch (stopError) {
            console.warn("[MusicPlayer] Failed to stop HLS load before retry:", stopError);
          }

          try {
            hlsInstanceRef.current?.loadSource(streamRetryUrlRef.current);
            hlsInstanceRef.current?.startLoad();
          } catch (reloadError) {
            console.error("[MusicPlayer] Failed to reload HLS source after token refresh:", reloadError);
            throw reloadError;
          }
        } else {
          console.warn("[MusicPlayer] Missing retry stream URL, skipping reload");
        }
      } catch (refreshError) {
        console.error("[MusicPlayer] Failed to refresh token during playback:", refreshError);
        toast({
          title: "PhiÃªn Ä‘Äƒng nháº­p Ä‘Ã£ háº¿t háº¡n",
          description: "Vui lÃ²ng Ä‘Äƒng nháº­p láº¡i Ä‘á»ƒ tiáº¿p tá»¥c nghe nháº¡c.",
          variant: "destructive",
        });
        setTimeout(() => {
          window.location.href = "/login";
        }, 1500);
      } finally {
        setIsLoading(false);
      }
    };

    const loadStreamUrl = async () => {
      try {
        // DÃ¹ng UUID trá»±c tiáº¿p tá»« currentSong; náº¿u chÆ°a cÃ³ thÃ¬ fetch láº¡i tá»« BE
        let songUuid = currentSong?.uuid;
        let fallbackPlaybackUrl: string | null = null;

        if (!songUuid) {
          console.warn("[MusicPlayer] Song missing uuid, fetching detail from backend", currentSong.id);
          try {
            const backendSong = await songsApi.getById(currentSong.id);
            songUuid = backendSong?.uuid;

            if (backendSong && songUuid) {
              const enrichedSong = { ...currentSong, uuid: songUuid };
              const updatedQueue = queue.map((song) =>
                song.id === enrichedSong.id ? { ...song, uuid: songUuid } : song
              );
              setQueue(updatedQueue);
              playSong(enrichedSong);
              return;
            }

            if (!songUuid) {
              console.warn("[MusicPlayer] Backend song still missing uuid, will use playback session fallback");
            }
          } catch (fetchError) {
            console.error("[MusicPlayer] Failed to fetch song detail for uuid fallback:", fetchError);
          }
        }

        if (!songUuid) {
          try {
            const session = await songsApi.getPlaybackUrl(currentSong.id);
            fallbackPlaybackUrl = session?.playbackUrl || null;
          } catch (sessionError) {
            console.error("[MusicPlayer] Failed to create playback session fallback:", sessionError);
          }
        }

        if (!songUuid && !fallbackPlaybackUrl) {
          setIsLoading(false);
          toast({
            title: "KhÃ´ng thá»ƒ phÃ¡t bÃ i hÃ¡t",
            description: "KhÃ´ng tÃ¬m tháº¥y nguá»“n stream há»£p lá»‡ cho bÃ i hÃ¡t nÃ y.",
            variant: "destructive",
          });
          setTimeout(() => handleNextClick(), 800);
          return;
        }

        // DÃ¹ng proxy endpoint náº¿u cÃ³ uuid, fallback playback URL náº¿u khÃ´ng
        let finalStreamUrlAbsolute = fallbackPlaybackUrl;
        if (songUuid) {
          const proxyBaseUrl = `/api/songs/${currentSong.id}/stream-proxy`;
          finalStreamUrlAbsolute = `${window.location.origin}${proxyBaseUrl}/${songUuid}_128kbps.m3u8`;
        }

        if (!finalStreamUrlAbsolute) {
          setIsLoading(false);
          toast({
            title: "KhÃ´ng thá»ƒ phÃ¡t bÃ i hÃ¡t",
            description: "KhÃ´ng tÃ¬m tháº¥y URL stream cho bÃ i hÃ¡t.",
            variant: "destructive",
          });
          setTimeout(() => handleNextClick(), 800);
          return;
        }

        streamRetryUrlRef.current = finalStreamUrlAbsolute;

        console.log("Using proxy endpoint for HLS streaming:", finalStreamUrlAbsolute);
        console.log("HLS.js will automatically resolve segment URLs relative to this playlist");

        if (Hls.isSupported()) {
          hls = new Hls({
            enableWorker: true,
            lowLatencyMode: false,
            backBufferLength: 30, // Giáº£m back buffer
            debug: false,
            // Äáº£m báº£o khÃ´ng loop playlist vÃ  khÃ´ng load quÃ¡ nhiá»u
            maxBufferLength: 20, // Giáº£m buffer Ä‘á»ƒ trÃ¡nh load quÃ¡ nhiá»u
            maxMaxBufferLength: 30,
            maxBufferSize: 30 * 1000 * 1000, // 30MB max buffer
            // QUAN TRá»ŒNG: KhÃ´ng set liveSyncDurationCount/liveMaxLatencyDurationCount cho VOD
            // VÃ¬ Ä‘Ã¢y lÃ  VOD playlist (cÃ³ #EXT-X-ENDLIST), khÃ´ng pháº£i live stream
            // Hls.js sáº½ tá»± Ä‘á»™ng detect VOD vÃ  khÃ´ng reload playlist
            // Giáº£m sá»‘ láº§n retry Ä‘á»ƒ trÃ¡nh load thÃªm khi háº¿t segment
            maxLoadingDelay: 2, // Giáº£m loading delay
            manifestLoadingTimeOut: 10000, // 10s timeout cho manifest
            manifestLoadingMaxRetry: 2, // Chá»‰ retry 2 láº§n cho manifest
            manifestLoadingRetryDelay: 1000, // Delay 1s giá»¯a cÃ¡c retry
            levelLoadingTimeOut: 10000, // 10s timeout cho level
            levelLoadingMaxRetry: 2, // Chá»‰ retry 2 láº§n cho level
            levelLoadingRetryDelay: 1000, // Delay 1s giá»¯a cÃ¡c retry
            fragLoadingTimeOut: 20000, // 20s timeout cho fragment
            fragLoadingMaxRetry: 3, // Retry 3 láº§n cho fragment (Ã­t hÆ¡n máº·c Ä‘á»‹nh)
            fragLoadingRetryDelay: 1000, // Delay 1s giá»¯a cÃ¡c retry
            xhrSetup: (xhr, url) => {
              xhr.withCredentials = true;
              // QUAN TRá»ŒNG: ThÃªm Authorization header vÃ o táº¥t cáº£ HLS requests Ä‘á»ƒ báº£o máº­t
              // Láº¥y token má»›i nháº¥t má»—i láº§n gá»­i request Ä‘á»ƒ luÃ´n dÃ¹ng access token hiá»‡n táº¡i
              const latestToken = getAuthToken();
              if (latestToken) {
                xhr.setRequestHeader('Authorization', `Bearer ${latestToken}`);
              }
            },
          });
          
          hlsInstanceRef.current = hls; // LÆ°u reference Ä‘á»ƒ cÃ³ thá»ƒ stop khi cáº§n

          hls.loadSource(finalStreamUrlAbsolute);
          hls.attachMedia(audio);
          
          // LÆ°u duration ban Ä‘áº§u Ä‘á»ƒ detect khi HLS loop
          let initialDuration = 0;
          
          hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
            setIsLoading(false);
            
            // QUAN TRá»ŒNG: Kiá»ƒm tra náº¿u playlist cÃ³ #EXT-X-ENDLIST (VOD - khÃ´ng loop)
            // Náº¿u cÃ³, Ä‘áº£m báº£o khÃ´ng reload playlist
            if (data && data.levels && data.levels.length > 0) {
              const level = data.levels[0];
              if (level.details && level.details.live === false) {
                console.log("âœ… VOD playlist detected (has #EXT-X-ENDLIST), will not reload");
                // VOD playlist khÃ´ng cáº§n reload, stop load khi háº¿t segment
              }
            }
            
            // LÆ°u duration ban Ä‘áº§u vÃ  sync lÃªn backend (CHá»ˆ active device má»›i sync duration)
            setTimeout(() => {
              if (audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
                initialDuration = audio.duration;
                const durationMs = Math.floor(initialDuration * 1000); // Convert to milliseconds
                setAudioDuration(initialDuration);
                console.log("Initial duration set from audio:", initialDuration, "seconds =", durationMs, "ms");
                
                // Sync duration lÃªn backend Ä‘á»ƒ cÃ¡c device khÃ¡c cÃ³ thÃ´ng tin (CHá»ˆ active device)
                if (isThisDeviceActive) {
                  updateDuration(durationMs).catch(err => {
                    console.error('[MusicPlayer] Failed to sync duration:', err);
                  });
                }
              }
            }, 1000);
            
            // Khi manifest parsed, náº¿u device nÃ y má»›i trá»Ÿ thÃ nh active, seek Ä‘áº¿n Ä‘Ãºng position
            if (isThisDeviceActive && position > 0) {
              // Äá»£i audio ready rá»“i seek Ä‘áº¿n Ä‘Ãºng position
              setTimeout(() => {
                if (audio.readyState >= 2 && audio.duration && !isNaN(audio.duration)) {
                  const positionSeconds = position / 1000; // Convert milliseconds to seconds
                  console.log('[MusicPlayer] ðŸŽ¯ Device má»›i trá»Ÿ thÃ nh active, seeking to position:', positionSeconds, 'seconds');
                  audio.currentTime = positionSeconds;
                  setCurrentTime(positionSeconds);
                  setProgress([(positionSeconds / audio.duration) * 100]);
                }
              }, 500);
            }
            
            // Tá»± Ä‘á»™ng play khi manifest parsed vÃ  isPlaying = true
            // QUAN TRá»ŒNG: Äáº£m báº£o seek Ä‘áº¿n Ä‘Ãºng position trÆ°á»›c khi play
            console.log('[MusicPlayer] Manifest parsed - checking play conditions:', {
              isPlaying: isPlayingRef.current,
              isThisDeviceActive,
              audioPaused: audio.paused,
              readyState: audio.readyState,
              currentDeviceId,
              activeDeviceId,
              position: position / 1000
            });
            
            if (isPlayingRef.current && isThisDeviceActive) {
              // QUAN TRá»ŒNG: Seek Ä‘áº¿n Ä‘Ãºng position trÆ°á»›c khi play
              const seekAndPlay = () => {
                if (audio.readyState >= 2 && audio.duration && !isNaN(audio.duration)) {
                  // Seek Ä‘áº¿n Ä‘Ãºng position tá»« Firebase
                  if (position > 0) {
                    const positionSeconds = position / 1000; // Convert milliseconds to seconds
                    const currentTimeDiff = Math.abs(audio.currentTime - positionSeconds);
                    
                    // Náº¿u position khÃ¡c biá»‡t > 0.5 giÃ¢y, seek Ä‘áº¿n Ä‘Ãºng vá»‹ trÃ­
                    if (currentTimeDiff > 0.5) {
                      console.log('[MusicPlayer] ðŸŽ¯ Seeking to position before play:', positionSeconds, 'seconds');
                      audio.currentTime = positionSeconds;
                      setCurrentTime(positionSeconds);
                      setProgress([(positionSeconds / audio.duration) * 100]);
                    }
                  }
                  
                  // Play sau khi Ä‘Ã£ seek
                  if (audio.paused && isPlayingRef.current && isThisDeviceActive) {
                    console.log('[MusicPlayer] âœ… Manifest parsed, seeking done, auto-playing...');
                    audio.play().catch((err) => {
                      console.error("Auto-play failed:", err);
                    });
                  }
                }
              };
              
              // Äá»£i má»™t chÃºt Ä‘á»ƒ audio ready vÃ  seek xong
              setTimeout(seekAndPlay, 500); // Giáº£m delay Ä‘á»ƒ play nhanh hÆ¡n
            } else {
              console.log('[MusicPlayer] âš ï¸ Cannot auto-play after manifest:', {
                isPlaying: isPlayingRef.current,
                isThisDeviceActive
              });
            }
          });
          
          // QUAN TRá»ŒNG: Listen khi HLS Ä‘Ã£ load háº¿t táº¥t cáº£ fragments (VOD)
          hls.on(Hls.Events.BUFFER_APPENDED, () => {
            // Kiá»ƒm tra náº¿u Ä‘Ã£ load háº¿t vÃ  gáº§n háº¿t bÃ i (trong vÃ²ng 2 giÃ¢y)
            if (initialDuration > 0 && audio.currentTime >= initialDuration - 2) {
              console.log("Near end of song, stopping HLS load. Current:", audio.currentTime, "Duration:", initialDuration);
              try {
                hlsInstanceRef.current?.stopLoad();
                console.log("HLS load stopped successfully");
              } catch (e) {
                console.warn("Failed to stop HLS near end:", e);
              }
            }
            // Náº¿u duration tÄƒng quÃ¡ nhiá»u so vá»›i ban Ä‘áº§u (HLS Ä‘ang loop), dá»«ng ngay
            if (initialDuration > 0 && audio.duration > initialDuration * 1.1) {
              console.warn("HLS loop detected! Duration:", audio.duration, "Initial:", initialDuration, "Stopping load");
              try {
                hlsInstanceRef.current?.stopLoad();
                // Force set duration vá» giÃ¡ trá»‹ ban Ä‘áº§u
                setAudioDuration(initialDuration);
              } catch (e) {
                console.warn("Failed to stop HLS loop:", e);
              }
            }
          });
          
          // QUAN TRá»ŒNG: Listen khi HLS Ä‘Ã£ load háº¿t táº¥t cáº£ fragments (VOD playlist)
          // Khi háº¿t fragments, stop load ngay Ä‘á»ƒ trÃ¡nh retry/reload
          hls.on(Hls.Events.BUFFER_EOS, () => {
            console.log("âœ… End of stream (EOS) detected, stopping HLS load");
            try {
              hlsInstanceRef.current?.stopLoad();
              console.log("HLS load stopped at end of stream");
            } catch (e) {
              console.warn("Failed to stop HLS at EOS:", e);
            }
          });

          hls.on(Hls.Events.LEVEL_LOADED, (_event, data) => {
            console.log("HLS level loaded", data);
            // Update duration when level is loaded - chá»‰ update 1 láº§n
            if (audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
              const currentDuration = duration || 0;
              // Chá»‰ update náº¿u duration tÄƒng (khÃ´ng pháº£i do HLS loop)
              if (audio.duration > currentDuration) {
                setAudioDuration(audio.duration);
                const durationMs = Math.floor(audio.duration * 1000);
                console.log("Duration updated from level loaded:", audio.duration, "seconds =", durationMs, "ms");
                
                // Sync duration lÃªn backend (CHá»ˆ active device)
                if (isThisDeviceActive) {
                  updateDuration(durationMs).catch(err => {
                    console.error('[MusicPlayer] Failed to sync duration from level loaded:', err);
                  });
                }
              }
            }
            
            // Tá»± Ä‘á»™ng play khi HLS Ä‘Ã£ load xong vÃ  isPlaying = true
            // QUAN TRá»ŒNG: Äáº£m báº£o seek Ä‘áº¿n Ä‘Ãºng position trÆ°á»›c khi play
            console.log('[MusicPlayer] HLS level loaded - checking play conditions:', {
              isPlaying,
              isThisDeviceActive,
              audioPaused: audio.paused,
              readyState: audio.readyState,
              currentDeviceId,
              activeDeviceId,
              position: position / 1000
            });
            
            const seekAndPlayAfterLevel = () => {
              if (audio.readyState >= 2 && audio.duration && !isNaN(audio.duration)) {
                // Seek Ä‘áº¿n Ä‘Ãºng position tá»« Firebase
                if (position > 0) {
                  const positionSeconds = position / 1000; // Convert milliseconds to seconds
                  const currentTimeDiff = Math.abs(audio.currentTime - positionSeconds);
                  
                  // Náº¿u position khÃ¡c biá»‡t > 0.5 giÃ¢y, seek Ä‘áº¿n Ä‘Ãºng vá»‹ trÃ­
                  if (currentTimeDiff > 0.5) {
                    console.log('[MusicPlayer] ðŸŽ¯ Seeking to position before play:', positionSeconds, 'seconds');
                    audio.currentTime = positionSeconds;
                    setCurrentTime(positionSeconds);
                    setProgress([(positionSeconds / audio.duration) * 100]);
                  }
                }
                
                // Play sau khi Ä‘Ã£ seek
                if (isPlaying && isThisDeviceActive && audio.paused) {
                  console.log('[MusicPlayer] âœ… HLS loaded, seeking done, auto-playing...');
                  audio.play().catch(err => {
                    console.error("Auto-play after HLS load failed:", err);
                  });
                }
              }
            };
            
            // Thá»­ play ngay náº¿u ready
            if (isPlaying && isThisDeviceActive && audio.paused && audio.readyState >= 2) {
              seekAndPlayAfterLevel();
            } else if (isPlaying && isThisDeviceActive && audio.paused) {
              // Náº¿u chÆ°a ready, Ä‘á»£i canplay event
              console.log('[MusicPlayer] âš ï¸ HLS loaded but audio not ready yet, waiting for canplay...');
              const onCanPlayAfterLevel = () => {
                if (isPlaying && isThisDeviceActive && audio.paused) {
                  seekAndPlayAfterLevel();
                }
                audio.removeEventListener('canplay', onCanPlayAfterLevel);
              };
              audio.addEventListener('canplay', onCanPlayAfterLevel);
            } else {
              console.log('[MusicPlayer] âš ï¸ Cannot auto-play:', {
                isPlaying,
                isThisDeviceActive,
                audioPaused: audio.paused,
                readyState: audio.readyState
              });
            }
          });
          
          // KHÃ”NG listen LEVEL_UPDATED vÃ¬ nÃ³ trigger liÃªn tá»¥c khi HLS loop
          // Chá»‰ dÃ¹ng LEVEL_LOADED Ä‘á»ƒ láº¥y duration ban Ä‘áº§u

          hls.on(Hls.Events.ERROR, (_event, data) => {
            // Chá»‰ log non-fatal errors, khÃ´ng bÃ¡o lá»—i
            if (!data.fatal) {
              console.warn("HLS non-fatal error (ignored):", data.type, data.details);
              return;
            }
            
            console.error("HLS fatal error:", data);
            let shouldShowError = true;
            let shouldRecover = false;
            
            // QUAN TRá»ŒNG: Náº¿u lá»—i 404 (file khÃ´ng tá»“n táº¡i), cÃ³ thá»ƒ lÃ  file Ä‘Ã£ bá»‹ xÃ³a trÃªn S3
            // Check response code Ä‘á»ƒ xÃ¡c Ä‘á»‹nh
            if (data.type === Hls.ErrorTypes.NETWORK_ERROR && 
                (data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR || 
                 data.details === Hls.ErrorDetails.LEVEL_LOAD_ERROR ||
                 data.details === Hls.ErrorDetails.FRAG_LOAD_ERROR)) {
              const response = data.response;
              const responseCode = response?.code ?? response?.status;

              if (responseCode === 401) {
                if (streamAuthRetryCountRef.current >= 2) {
                  console.error("[MusicPlayer] Stream auth retry limit reached. Will show error.");
                } else {
                  streamAuthRetryCountRef.current += 1;
                  shouldShowError = false;
                  console.warn("[MusicPlayer] Stream request unauthorized, refreshing token...");
                  refreshTokenAndRetryStream();
                  return;
                }
              }
              // Náº¿u lÃ  404 hoáº·c 403 (signed URL háº¿t háº¡n hoáº·c file khÃ´ng tá»“n táº¡i), file Ä‘Ã£ bá»‹ xÃ³a
              if (response && (responseCode === 404 || responseCode === 403)) {
                console.error("âš ï¸ Audio file not found (404/403), likely deleted from S3 or CloudFront cache expired");
                setIsLoading(false);
                toast({
                  title: "BÃ i hÃ¡t khÃ´ng kháº£ dá»¥ng",
                  description: "File audio Ä‘Ã£ bá»‹ xÃ³a hoáº·c khÃ´ng cÃ²n kháº£ dá»¥ng. Äang chuyá»ƒn sang bÃ i tiáº¿p theo...",
                  variant: "destructive",
                  duration: 3000,
                });
                // Auto skip to next song
                setTimeout(() => {
                  handleNextClick();
                }, 1000);
                return; // KhÃ´ng thá»­ recover ná»¯a
              }
              
              // Náº¿u lÃ  bitrate playlist chÆ°a cÃ³, fallback vá» master playlist
              const currentUrl = hls?.url || '';
              if (currentUrl.includes('_128kbps.m3u8')) {
                console.warn("âš ï¸ Bitrate playlist not found, falling back to master playlist");
                // Fallback vá» master playlist
                const masterUrl = currentUrl.replace('_128kbps.m3u8', '.m3u8');
                try {
                  if (hls) {
                    hls.loadSource(masterUrl);
                    shouldRecover = true;
                    shouldShowError = false;
                    console.log("ðŸ”„ Fallback to master playlist:", masterUrl);
                    return;
                  }
                } catch (e) {
                  console.error("Failed to fallback to master playlist:", e);
                }
              }
            }
            
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                // Thá»­ recover trÆ°á»›c
                try {
                  hls?.startLoad();
                  shouldRecover = true;
                  shouldShowError = false; // KhÃ´ng bÃ¡o lá»—i ngay, Ä‘á»£i xem recover cÃ³ thÃ nh cÃ´ng khÃ´ng
                  console.log("Attempting to recover from network error...");
                } catch (e) {
                  console.error("Failed to recover from network error:", e);
                }
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                // Thá»­ recover trÆ°á»›c
                try {
                  hls?.recoverMediaError();
                  shouldRecover = true;
                  shouldShowError = false; // KhÃ´ng bÃ¡o lá»—i ngay, Ä‘á»£i xem recover cÃ³ thÃ nh cÃ´ng khÃ´ng
                  console.log("Attempting to recover from media error...");
                } catch (e) {
                  console.error("Failed to recover from media error:", e);
                }
                break;
              default:
                // CÃ¡c lá»—i khÃ¡c khÃ´ng recover Ä‘Æ°á»£c
                break;
            }

            // Chá»‰ hiá»ƒn thá»‹ error sau khi Ä‘Ã£ thá»­ recover vÃ  Ä‘á»£i má»™t chÃºt
            // Ä‘á»ƒ xem cÃ³ recover Ä‘Æ°á»£c khÃ´ng
            if (shouldShowError) {
              setIsLoading(false);
              let errorMsg = `HLS stream error: ${data.type || "unknown"}`;
              if (data.details) {
                errorMsg += ` - ${data.details}`;
              }
              if (data.response) {
                errorMsg += ` (Response: ${data.response.code || "N/A"})`;
              }
              toast({
                title: "Playback error",
                description: errorMsg,
                variant: "destructive",
              });
            } else if (shouldRecover) {
              // Äá»£i 3 giÃ¢y, náº¿u váº«n khÃ´ng play Ä‘Æ°á»£c thÃ¬ má»›i bÃ¡o lá»—i
              setTimeout(() => {
                if (audio.paused || audio.readyState < 2) {
                  console.error("Recovery failed, audio still not playing");
                  setIsLoading(false);
                  toast({
                    title: "Playback error",
                    description: "Failed to recover from stream error. Trying next song...",
                    variant: "destructive",
                  });
                  setTimeout(() => handleNextClick(), 1000);
                } else {
                  console.log("Recovery successful, audio is playing");
                }
              }, 3000);
            }
          });
        } else if (audio.canPlayType("application/vnd.apple.mpegurl")) {
          safariMetadataListener = () => {
            setIsLoading(false);
            if (isPlayingRef.current) {
              audio.play().catch((err) => {
                console.error("Auto-play failed:", err);
              });
            }
            if (safariMetadataListener) {
              audio.removeEventListener("loadedmetadata", safariMetadataListener);
              safariMetadataListener = null;
            }
          };

          audio.addEventListener("loadedmetadata", safariMetadataListener);
          audio.src = finalStreamUrlAbsolute; // DÃ¹ng absolute URL cho Safari
          audio.load();
        } else {
          setIsLoading(false);
          toast({
            title: "Playback error",
            description: "Your browser does not support HLS streaming",
            variant: "destructive",
          });
        }
      } catch (error: any) {
        console.error("Failed to start proxy stream:", error);
        setIsLoading(false);
        
        // Check if error is due to audio file not found on S3
        const errorMessage = error?.response?.data?.error || error?.response?.data?.message || error?.message || "";
        const isAudioNotFound = error?.response?.status === 404 || 
                                errorMessage.includes("AUDIO_NOT_FOUND") ||
                                errorMessage.includes("not found on S3") ||
                                errorMessage.includes("may have been deleted");
        
        if (isAudioNotFound) {
          toast({
            title: "BÃ i hÃ¡t khÃ´ng kháº£ dá»¥ng",
            description: "File audio Ä‘Ã£ bá»‹ xÃ³a. Äang chuyá»ƒn sang bÃ i tiáº¿p theo...",
            variant: "destructive",
            duration: 3000,
          });
          // Auto skip to next song after 1 second
          setTimeout(() => {
            handleNextClick();
          }, 1000);
        } else {
          toast({
            title: "Playback error",
            description: "Failed to get stream URL. Please try again.",
            variant: "destructive",
          });
        }
      }
    };

    loadStreamUrl();

    const handleCanPlay = () => {
      setIsLoading(false);
      // QUAN TRá»ŒNG: Check isPlaying tá»« context (khÃ´ng pháº£i ref) Ä‘á»ƒ Ä‘áº£m báº£o sync
      // VÃ  chá»‰ play náº¿u device nÃ y lÃ  active device
      // DÃ¹ng cáº£ isPlayingRef vÃ  isPlaying Ä‘á»ƒ Ä‘áº£m báº£o khÃ´ng miss
      const shouldPlay = isPlayingRef.current || isPlaying;
      if (shouldPlay && isThisDeviceActive && audio.paused) {
        console.log('[MusicPlayer] âœ… Audio can play, auto-playing...', {
          isPlaying,
          isPlayingRef: isPlayingRef.current,
          isThisDeviceActive,
          audioPaused: audio.paused,
          readyState: audio.readyState
        });
        audio.play().catch((err) => {
          console.error("Auto-play failed:", err);
          toast({
            title: "Playback paused",
            description: "Click play to continue",
          });
        });
      } else {
        console.log('[MusicPlayer] âš ï¸ Audio can play but not playing:', {
          isPlaying,
          isPlayingRef: isPlayingRef.current,
          isThisDeviceActive,
          audioPaused: audio.paused,
          readyState: audio.readyState
        });
      }
    };

    // Chá»‰ add error listener cho Safari native HLS, khÃ´ng add cho Hls.js
    // VÃ¬ Hls.js sáº½ tá»± xá»­ lÃ½ errors qua HLS.Events.ERROR
    if (!Hls.isSupported() && audio.canPlayType("application/vnd.apple.mpegurl")) {
      const handleLoadError = (e: Event) => {
        const target = e.target as HTMLAudioElement;
        console.error("Audio load error:", e);
        setIsLoading(false);
        // Chá»‰ bÃ¡o lá»—i náº¿u thá»±c sá»± khÃ´ng load Ä‘Æ°á»£c (khÃ´ng pháº£i recoverable)
        if (target.error && target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
          toast({
            title: "Load error",
            description: "Failed to load audio. Skipping to next song...",
            variant: "destructive",
          });
          loadErrorTimeout = setTimeout(() => {
            handleNextClick();
          }, 2000);
        }
      };
      audio.addEventListener("error", handleLoadError);
      cleanupCallbacks.current.push(() => {
        audio.removeEventListener("error", handleLoadError);
      });
    }
    
    audio.addEventListener("canplay", handleCanPlay);

    return () => {
      audio.removeEventListener("canplay", handleCanPlay);
      if (safariMetadataListener) {
        audio.removeEventListener("loadedmetadata", safariMetadataListener);
        safariMetadataListener = null;
      }
      if (loadErrorTimeout) {
        clearTimeout(loadErrorTimeout);
      }
      cleanupCallbacks.current.forEach((cb) => {
        try {
          cb();
        } catch (err) {
          console.warn("Cleanup callback failed", err);
        }
      });
      cleanupCallbacks.current = [];
      // Cleanup HLS instance
      if (hlsInstanceRef.current) {
        try {
          hlsInstanceRef.current.stopLoad();
          hlsInstanceRef.current.destroy();
          console.log("HLS instance destroyed (cleanup)");
        } catch (e) {
          console.warn("Error destroying HLS instance:", e);
        }
        hlsInstanceRef.current = null;
      }
      if (hls) {
        try {
          hls.stopLoad();
          hls.destroy();
        } catch (e) {
          console.warn("Error destroying HLS:", e);
        }
        hls = null;
      }
      audio.pause();
      audio.src = "";
    };
    // eslint-disable-next-line react-hooks-exhaustive-deps
  }, [currentSong, isThisDeviceActive]); // Reload when song changes OR when device becomes active


  // Khi device trá»Ÿ thÃ nh active vÃ  Ä‘Ã£ cÃ³ currentSong, Ä‘áº£m báº£o load HLS vÃ  seek Ä‘Ãºng position
  useEffect(() => {
    if (!currentSong || !isThisDeviceActive) return;
    
    const audio = audioRef.current;
    if (!audio) return;
    
    // Náº¿u chÆ°a cÃ³ src (chÆ°a load HLS), trigger load
    if (!audio.src || audio.src === '') {
      console.log('[MusicPlayer] ðŸ”„ Device má»›i trá»Ÿ thÃ nh active, cáº§n load HLS file...');
      // Force re-trigger load song effect báº±ng cÃ¡ch set currentSong láº¡i
      // useEffect load song sáº½ tá»± Ä‘á»™ng load vÃ¬ isThisDeviceActive = true
    } else if (audio.readyState >= 2 && position > 0) {
      // Náº¿u Ä‘Ã£ cÃ³ src vÃ  ready, seek Ä‘áº¿n Ä‘Ãºng position ngay
      const positionSeconds = position / 1000;
      const currentTimeDiff = Math.abs(audio.currentTime - positionSeconds);
      
      if (currentTimeDiff > 1) {
        console.log('[MusicPlayer] ðŸŽ¯ Device má»›i trá»Ÿ thÃ nh active, seeking to position:', positionSeconds, 'seconds');
        audio.currentTime = positionSeconds;
        setCurrentTime(positionSeconds);
        if (audio.duration && !isNaN(audio.duration)) {
          setProgress([(positionSeconds / audio.duration) * 100]);
        }
      }
    }
  }, [isThisDeviceActive, currentSong, position]);

  // Handle play/pause toggle separately
    // Handle play/pause toggle separately - only if this device is active
    // Non-active devices sync state but don't play audio
    useEffect(() => {
      if (!audioRef.current || isLoading) {
        if (isLoading) {
          console.log('[MusicPlayer] Skipping play/pause - still loading');
        }
        return;
      }

      const audio = audioRef.current;

      console.log('[MusicPlayer] Play/pause effect triggered:', {
        isPlaying,
        isThisDeviceActive,
        audioPaused: audio.paused,
        readyState: audio.readyState,
        currentDeviceId,
        activeDeviceId,
        hasSrc: !!audio.src
      });

      // Only play audio if this device is the active device
      if (isPlaying && isThisDeviceActive && audio.paused) {
        // Khi device nÃ y trá»Ÿ thÃ nh active, seek Ä‘áº¿n Ä‘Ãºng position tá»« Firebase
        if (position > 0 && audio.duration && !isNaN(audio.duration) && audio.readyState >= 2) {
          const positionSeconds = position / 1000; // Convert milliseconds to seconds
          const currentTimeDiff = Math.abs(audio.currentTime - positionSeconds);
          
          // Náº¿u position khÃ¡c biá»‡t > 1 giÃ¢y, seek Ä‘áº¿n Ä‘Ãºng vá»‹ trÃ­
          if (currentTimeDiff > 1) {
            console.log('[MusicPlayer] ðŸŽ¯ Device má»›i trá»Ÿ thÃ nh active, seeking to position:', positionSeconds, 'seconds');
            audio.currentTime = positionSeconds;
            setCurrentTime(positionSeconds);
            setProgress([(positionSeconds / audio.duration) * 100]);
          }
        }
        
        // QUAN TRá»ŒNG: Äá»£i audio ready (readyState >= 2) hoáº·c thá»­ play ngay
        // Náº¿u chÆ°a ready, Ä‘á»£i cáº£ canplay vÃ  loadeddata events
        const attemptPlay = () => {
          if (isPlaying && isThisDeviceActive && audio.paused && audio.readyState >= 2) {
            console.log('[MusicPlayer] âœ… Playing audio - this device is active, readyState >= 2');
            audio.play().catch(err => {
              console.error("Play error:", err);
              toast({
                title: "Playback error",
                description: "Unable to play audio",
                variant: "destructive",
              });
            });
            return true; // ÄÃ£ play thÃ nh cÃ´ng
          }
          return false; // ChÆ°a play Ä‘Æ°á»£c
        };
        
        // Thá»­ play ngay náº¿u ready
        if (attemptPlay()) {
          return; // ÄÃ£ play thÃ nh cÃ´ng
        }
        
        // Náº¿u chÆ°a ready, Ä‘á»£i cáº£ canplay vÃ  loadeddata events
        console.log('[MusicPlayer] Audio not ready yet (readyState:', audio.readyState, '), waiting for canplay/loadeddata...');
        
        let hasPlayed = false;
        
        const onCanPlay = () => {
          if (!hasPlayed && attemptPlay()) {
            hasPlayed = true;
            audio.removeEventListener('canplay', onCanPlay);
            audio.removeEventListener('loadeddata', onLoadedData);
          }
        };
        
        const onLoadedData = () => {
          if (!hasPlayed && isPlaying && isThisDeviceActive && audio.paused) {
            // Seek Ä‘áº¿n Ä‘Ãºng position trÆ°á»›c khi play
            if (position > 0 && audio.duration && !isNaN(audio.duration)) {
              const positionSeconds = position / 1000;
              audio.currentTime = positionSeconds;
              setCurrentTime(positionSeconds);
              setProgress([(positionSeconds / audio.duration) * 100]);
            }
            console.log('[MusicPlayer] âœ… Audio loaded, playing now...');
            audio.play().catch(err => {
              console.error("Play error after loadeddata:", err);
            });
            hasPlayed = true;
            audio.removeEventListener('canplay', onCanPlay);
            audio.removeEventListener('loadeddata', onLoadedData);
          }
        };
        
        // Listen cáº£ canplay vÃ  loadeddata Ä‘á»ƒ Ä‘áº£m báº£o play Ä‘Æ°á»£c ngay khi ready
        audio.addEventListener('canplay', onCanPlay);
        audio.addEventListener('loadeddata', onLoadedData);
        
        // Cleanup listeners sau 5 giÃ¢y náº¿u chÆ°a play Ä‘Æ°á»£c
        const cleanupTimeout = setTimeout(() => {
          audio.removeEventListener('canplay', onCanPlay);
          audio.removeEventListener('loadeddata', onLoadedData);
        }, 5000);
        
        return () => {
          audio.removeEventListener('canplay', onCanPlay);
          audio.removeEventListener('loadeddata', onLoadedData);
          clearTimeout(cleanupTimeout);
        };
      } else if (!isThisDeviceActive && !audio.paused) {
        // Pause audio if this device is not active (but state is synced)
        console.log('[MusicPlayer] Pausing audio - this device is not active');
        audio.pause();
      } else if (!isPlaying && !audio.paused) {
        // Pause if isPlaying is false
        console.log('[MusicPlayer] Pausing audio - isPlaying is false');
        audio.pause();
      } else if (isPlaying && !isThisDeviceActive) {
        // State says playing but this device is not active - don't play audio
        // UI will show playing state but no audio output
        console.log('[MusicPlayer] State is playing but this device is not active - no audio output');
        if (!audio.paused) {
          audio.pause();
        }
      }
    }, [isPlaying, isLoading, isThisDeviceActive, currentDeviceId, activeDeviceId, position]);
  
  // QUAN TRá»ŒNG: Khi device nÃ y trá»Ÿ thÃ nh active device, Ä‘áº£m báº£o seek Ä‘áº¿n Ä‘Ãºng position vÃ  play ngay
  useEffect(() => {
    if (!audioRef.current || !currentSong || !isThisDeviceActive) return;
    
    const audioElement = audioRef.current;
    const hlsInstance = hlsInstanceRef.current;
    
    // Náº¿u chÆ°a cÃ³ src hoáº·c src khÃ´ng Ä‘Ãºng vá»›i bÃ i hiá»‡n táº¡i, cáº§n load láº¡i
    // NhÆ°ng viá»‡c load sáº½ Ä‘Æ°á»£c xá»­ lÃ½ bá»Ÿi useEffect cá»§a currentSong
    // á»ž Ä‘Ã¢y chá»‰ Ä‘áº£m báº£o seek vÃ  play náº¿u Ä‘Ã£ cÃ³ src vÃ  ready
    if (audioElement.src && audioElement.src.includes(currentSong.id)) {
      // ÄÃ£ cÃ³ file, seek Ä‘áº¿n Ä‘Ãºng position vÃ  play náº¿u isPlaying = true
      if (isPlaying && audioElement.paused) {
        console.log('[MusicPlayer] ðŸ”„ Device nÃ y vá»«a trá»Ÿ thÃ nh active device, Ä‘Ã£ cÃ³ file, seeking vÃ  playing...', {
          readyState: audioElement.readyState,
          hasHls: !!hlsInstance,
          hlsState: hlsInstance ? hlsInstance.media?.readyState : 'no-hls'
        });
        
        const seekAndPlay = () => {
          // Check cáº£ audio readyState vÃ  duration
          const isReady = audioElement.readyState >= 2 && audioElement.duration && !isNaN(audioElement.duration) && audioElement.duration > 0;
          
          if (isReady) {
            // QUAN TRá»ŒNG: Seek Ä‘áº¿n Ä‘Ãºng position tá»« Firebase trÆ°á»›c khi play
            if (position > 0) {
              const positionSeconds = position / 1000; // Convert milliseconds to seconds
              const currentTimeDiff = Math.abs(audioElement.currentTime - positionSeconds);
              
              // Náº¿u position khÃ¡c biá»‡t > 0.5 giÃ¢y, seek Ä‘áº¿n Ä‘Ãºng vá»‹ trÃ­
              if (currentTimeDiff > 0.5) {
                console.log('[MusicPlayer] ðŸŽ¯ Device má»›i trá»Ÿ thÃ nh active, seeking to position:', positionSeconds, 'seconds');
                audioElement.currentTime = positionSeconds;
                setCurrentTime(positionSeconds);
                setProgress([(positionSeconds / audioElement.duration) * 100]);
              }
            }
            
            // Play sau khi Ä‘Ã£ seek
            if (isPlaying && isThisDeviceActive && audioElement.paused) {
              console.log('[MusicPlayer] âœ… Audio ready, seeking done, playing immediately...');
              audioElement.play().catch(err => {
                console.error("Play error when becoming active:", err);
              });
            }
          } else {
            console.log('[MusicPlayer] â³ Audio not ready yet:', {
              readyState: audioElement.readyState,
              duration: audioElement.duration,
              hasDuration: !!(audioElement.duration && !isNaN(audioElement.duration))
            });
          }
        };
        
        // Náº¿u Ä‘Ã£ ready, play ngay
        if (audioElement.readyState >= 2 && audioElement.duration && !isNaN(audioElement.duration) && audioElement.duration > 0) {
          seekAndPlay();
        } else {
          // Äá»£i audio ready - dÃ¹ng nhiá»u events Ä‘á»ƒ Ä‘áº£m báº£o catch Ä‘Æ°á»£c
          console.log('[MusicPlayer] â³ Audio not ready yet, waiting for events...');
          
          let hasPlayed = false;
          
          const tryPlay = () => {
            if (hasPlayed) return;
            if (isPlaying && isThisDeviceActive && audioElement.paused) {
              const isReady = audioElement.readyState >= 2 && audioElement.duration && !isNaN(audioElement.duration) && audioElement.duration > 0;
              if (isReady) {
                hasPlayed = true;
                seekAndPlay();
              }
            }
          };
          
          // Listen nhiá»u events Ä‘á»ƒ Ä‘áº£m báº£o catch Ä‘Æ°á»£c
          const onCanPlay = () => {
            console.log('[MusicPlayer] âœ… canplay event fired');
            tryPlay();
          };
          
          const onLoadedData = () => {
            console.log('[MusicPlayer] âœ… loadeddata event fired');
            tryPlay();
          };
          
          const onLoadedMetadata = () => {
            console.log('[MusicPlayer] âœ… loadedmetadata event fired');
            tryPlay();
          };
          
          // Náº¿u cÃ³ HLS, cÅ©ng listen HLS events
          if (hlsInstance) {
            const onHlsManifestParsed = () => {
              console.log('[MusicPlayer] âœ… HLS manifest parsed event fired');
              setTimeout(tryPlay, 500); // Äá»£i má»™t chÃºt Ä‘á»ƒ audio ready
            };
            
            const onHlsLevelLoaded = () => {
              console.log('[MusicPlayer] âœ… HLS level loaded event fired');
              setTimeout(tryPlay, 500);
            };
            
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, onHlsManifestParsed);
            hlsInstance.on(Hls.Events.LEVEL_LOADED, onHlsLevelLoaded);
            
            // Cleanup HLS listeners sau khi play hoáº·c timeout
            const cleanupHlsListeners = () => {
              try {
                if (hlsInstance) {
                  hlsInstance.off(Hls.Events.MANIFEST_PARSED, onHlsManifestParsed);
                  hlsInstance.off(Hls.Events.LEVEL_LOADED, onHlsLevelLoaded);
                }
              } catch (e) {
                console.warn('[MusicPlayer] Failed to cleanup HLS listeners:', e);
              }
            };
            
            // Cleanup sau 10s hoáº·c khi Ä‘Ã£ play
            const cleanupTimeout = setTimeout(cleanupHlsListeners, 10000);
            
            // Polling Ä‘á»ƒ check readyState má»—i 500ms (fallback náº¿u events khÃ´ng fire)
            const pollInterval = setInterval(() => {
              if (audioElement.readyState >= 2 && audioElement.duration && !isNaN(audioElement.duration) && audioElement.duration > 0) {
                console.log('[MusicPlayer] âœ… Polling detected audio ready');
                clearInterval(pollInterval);
                clearTimeout(cleanupTimeout);
                cleanupHlsListeners();
                tryPlay();
              }
            }, 500);
            
            // Cleanup polling sau 10s
            setTimeout(() => {
              clearInterval(pollInterval);
            }, 10000);
            
            // Store cleanup functions Ä‘á»ƒ dÃ¹ng sau
            const cleanupHls = () => {
              clearInterval(pollInterval);
              clearTimeout(cleanupTimeout);
              cleanupHlsListeners();
            };
            
            // Store trong closure Ä‘á»ƒ cleanup sau
            (audioElement as any).__hlsCleanupWhenActive = cleanupHls;
          }
          
          audioElement.addEventListener('canplay', onCanPlay);
          audioElement.addEventListener('loadeddata', onLoadedData);
          audioElement.addEventListener('loadedmetadata', onLoadedMetadata);
          
          // Fallback: thá»­ play sau 2 giÃ¢y náº¿u váº«n chÆ°a ready
          const fallbackTimeout = setTimeout(() => {
            console.log('[MusicPlayer] âš ï¸ Fallback: trying to play after 2s timeout');
            tryPlay();
          }, 2000);
          
          // Cleanup function cho audio events
          const cleanupAudioEvents = () => {
            audioElement.removeEventListener('canplay', onCanPlay);
            audioElement.removeEventListener('loadeddata', onLoadedData);
            audioElement.removeEventListener('loadedmetadata', onLoadedMetadata);
            clearTimeout(fallbackTimeout);
          };
          
          // Return cleanup function
          return () => {
            cleanupAudioEvents();
            // Náº¿u cÃ³ HLS cleanup, gá»i nÃ³
            if ((audioElement as any).__hlsCleanupWhenActive) {
              (audioElement as any).__hlsCleanupWhenActive();
              delete (audioElement as any).__hlsCleanupWhenActive;
            }
          };
        }
      }
    }
  }, [isThisDeviceActive, currentSong, isPlaying, position]);
  
  // Track current playback time vÃ  sync position real-time
  useEffect(() => {
    if (!audioRef.current) return;

    let lastTick = Date.now();
    let lastPositionSync = 0; // Track last position sync time Ä‘á»ƒ trÃ¡nh spam
    
    const interval = setInterval(() => {
      const audio = audioRef.current;
      if (!audio) {
        return;
      }

      setCurrentTime(audio.currentTime);

      // Chá»‰ sync position náº¿u device nÃ y lÃ  active device vÃ  Ä‘ang playing
      if (isThisDeviceActive && isPlaying && !audio.paused) {
        const now = Date.now();
        const currentPositionMs = Math.floor(audio.currentTime * 1000);
        const currentDurationMs = audio.duration && !isNaN(audio.duration) 
          ? Math.floor(audio.duration * 1000) 
          : undefined;
        
        // Sync position vÃ  duration má»—i giÃ¢y (1000ms) Ä‘á»ƒ real-time
        if (now - lastPositionSync >= 1000) {
          lastPositionSync = now;
          updatePosition(currentPositionMs, currentDurationMs).catch(err => {
            console.error('[MusicPlayer] Failed to sync position:', err);
          });
        }
      }

      if (audio.paused) {
        lastTick = Date.now();
        return;
      }

      const now = Date.now();
      const deltaSeconds = (now - lastTick) / 1000;
      lastTick = now;

      if (deltaSeconds > 0) {
        listenedSecondsRef.current += deltaSeconds;
      }
    }, 500);

    return () => clearInterval(interval);
  }, [isPlaying, isThisDeviceActive, updatePosition]);

  // Sync position vÃ  duration tá»« Firebase khi khÃ´ng pháº£i active device (Ä‘á»ƒ hiá»ƒn thá»‹ Ä‘Ãºng progress)
  useEffect(() => {
    if (!currentSong) return;
    
    // Sync duration tá»« Firebase Ä‘á»ƒ non-active devices cÃ³ Ä‘áº§y Ä‘á»§ thÃ´ng tin
    if (duration > 0 && duration !== duration) {
      // Duration tá»« context (Firebase) Ä‘Ã£ cÃ³, khÃ´ng cáº§n set local state
    }
    
    const audio = audioRef.current;
    if (!audio) return;
    
    // Chá»‰ sync position náº¿u khÃ´ng pháº£i active device (active device tá»± update position)
    if (!isThisDeviceActive && position > 0) {
      const positionSeconds = position / 1000; // Convert milliseconds to seconds
      
      // Náº¿u cÃ³ duration tá»« Firebase, dÃ¹ng nÃ³ Ä‘á»ƒ tÃ­nh progress
      const effectiveDuration = duration > 0 ? duration / 1000 : (audio.duration && !isNaN(audio.duration) ? audio.duration : 0);
      
      if (effectiveDuration > 0) {
        const currentTimeDiff = Math.abs(audio.currentTime - positionSeconds);
        
        // Sync position náº¿u khÃ¡c biá»‡t > 0.5 giÃ¢y (Ä‘á»ƒ trÃ¡nh conflict khi user Ä‘ang seek)
        if (currentTimeDiff > 0.5) {
          console.log('[MusicPlayer] ðŸ”„ Syncing position from Firebase (non-active device):', positionSeconds, 'seconds');
          audio.currentTime = positionSeconds;
          setCurrentTime(positionSeconds);
          setProgress([(positionSeconds / effectiveDuration) * 100]);
        } else {
          // Váº«n update progress bar ngay cáº£ khi khÃ´ng seek
          setCurrentTime(positionSeconds);
          setProgress([(positionSeconds / effectiveDuration) * 100]);
        }
      }
    }
  }, [position, duration, isThisDeviceActive, currentSong]);

  // Update progress and handle song end
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const updateProgress = () => {
      if (audio.duration && !isNaN(audio.duration)) {
        const progressPercent = (audio.currentTime / audio.duration) * 100;
        setProgress([progressPercent]);
        setCurrentTime(audio.currentTime); // Also update currentTime here for consistency
      }
    };

    // LÆ°u duration ban Ä‘áº§u Ä‘á»ƒ trÃ¡nh update khi HLS loop
    let initialDurationForCheck = 0;
    
    const handleDurationUpdate = () => {
      if (audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
        // Láº§n Ä‘áº§u tiÃªn, lÆ°u duration ban Ä‘áº§u
        if (initialDurationForCheck === 0) {
          initialDurationForCheck = audio.duration;
          setAudioDuration(audio.duration);
          // Sync duration lÃªn backend (CHá»ˆ active device)
          const durationMs = Math.floor(audio.duration * 1000);
          if (isThisDeviceActive) {
            updateDuration(durationMs).catch(err => {
              console.error('[MusicPlayer] Failed to sync duration:', err);
            });
          }
          console.log("Initial duration set in handleDurationUpdate:", audio.duration);
        } else if (audio.duration <= initialDurationForCheck * 1.05) {
          // Chá»‰ update náº¿u duration khÃ´ng tÄƒng quÃ¡ 5% (cho phÃ©p sai sá»‘ nhá»)
          setAudioDuration(audio.duration);
          // Sync duration lÃªn backend (CHá»ˆ active device)
          const durationMs = Math.floor(audio.duration * 1000);
          if (isThisDeviceActive) {
            updateDuration(durationMs).catch(err => {
              console.error('[MusicPlayer] Failed to sync duration:', err);
            });
          }
        } else {
          // Duration tÄƒng quÃ¡ nhiá»u, cÃ³ thá»ƒ HLS Ä‘ang loop - khÃ´ng update
          console.warn("Duration increased too much, possible HLS loop. Ignoring update. Current:", audio.duration, "Initial:", initialDurationForCheck);
        }
      }
    };

    // Reset flag khi song thay Ä‘á»•i
    hasTriggeredEndedRef.current = false;
    
    const handleEnded = () => {
      if (hasTriggeredEndedRef.current) return; // TrÃ¡nh trigger nhiá»u láº§n
      hasTriggeredEndedRef.current = true;
      
      console.log("Song ended event triggered, repeat mode:", repeatMode);
      console.log("Final duration:", audio.duration, "Final time:", audio.currentTime);
      
      // Dá»«ng HLS load khi bÃ i hÃ¡t káº¿t thÃºc
      if (hlsInstanceRef.current) {
        try {
          hlsInstanceRef.current.stopLoad();
          console.log("HLS load stopped (ended event)");
        } catch (e) {
          console.warn("Failed to stop HLS load:", e);
        }
      }

      if (repeatMode === "one") {
        hasTriggeredEndedRef.current = false;
        audio.currentTime = 0;
        if (hlsInstanceRef.current) {
          try {
            hlsInstanceRef.current.startLoad();
          } catch (e) {
            console.warn("Failed to restart HLS load:", e);
          }
        }
        audio.play().catch(err => console.error("Repeat play error:", err));
      } else {
        const finishedId = currentSong?.id;
        const hasNext = hasNextQueueSong();
        if (hasNext) {
          playNext();
          finalizeQueueAfterPlayback(finishedId);
        } else {
          finalizeQueueAfterPlayback(finishedId);
          if (!startSuggestionsPlayback()) {
            console.warn("No songs left in queue or suggestions");
          }
        }
      }
    };

    // Fallback: Check if song should end based on duration and currentTime
    // HLS cÃ³ thá»ƒ khÃ´ng trigger ended event Ä‘Ãºng cÃ¡ch, Ä‘áº·c biá»‡t khi playlist loop
    const checkSongEnd = () => {
      if (hasTriggeredEndedRef.current) return; // ÄÃ£ trigger rá»“i, khÃ´ng check ná»¯a
      
      if (audio.duration && !isNaN(audio.duration) && audio.duration > 0) {
        // Náº¿u currentTime >= duration (hoáº·c gáº§n báº±ng trong vÃ²ng 0.3 giÃ¢y) vÃ  Ä‘ang play
        // thÃ¬ force stop vÃ  chuyá»ƒn bÃ i ngay (khÃ´ng Ä‘á»ƒ HLS load thÃªm segment)
        const timeRemaining = audio.duration - audio.currentTime;
        if (timeRemaining <= 0.3 && !audio.paused && audio.readyState >= 2) {
          console.log("Song should end (fallback check), forcing stop and switching. Duration:", audio.duration, "Current:", audio.currentTime);
          // Dá»«ng HLS load ngay Ä‘á»ƒ trÃ¡nh load thÃªm segment
          if (hlsInstanceRef.current) {
            try {
              hlsInstanceRef.current.stopLoad();
              console.log("HLS load stopped");
            } catch (e) {
              console.warn("Failed to stop HLS load:", e);
            }
          }
          // Force stop audio ngay
          audio.pause();
          hasTriggeredEndedRef.current = true; // ÄÃ¡nh dáº¥u Ä‘Ã£ trigger Ä‘á»ƒ trÃ¡nh trigger láº¡i
          // Chuyá»ƒn bÃ i ngay láº­p tá»©c
          if (repeatMode === "one") {
            hasTriggeredEndedRef.current = false;
            audio.currentTime = 0;
            if (hlsInstanceRef.current) {
              try {
                hlsInstanceRef.current.startLoad();
              } catch (e) {
                console.warn("Failed to restart HLS load:", e);
              }
            }
            audio.play().catch(err => console.error("Repeat play error:", err));
          } else {
            console.log("Auto-playing next song");
            const finishedId = currentSong?.id;
            if (hasNextQueueSong()) {
              playNext();
              finalizeQueueAfterPlayback(finishedId);
            } else {
              finalizeQueueAfterPlayback(finishedId);
              if (!startSuggestionsPlayback()) {
                console.warn("No songs left to auto-play");
              }
            }
          }
          return;
        }
        // Náº¿u currentTime vÆ°á»£t quÃ¡ duration (do HLS loop), force stop vÃ  chuyá»ƒn bÃ i ngay
        if (audio.currentTime > audio.duration && audio.duration > 0) {
          console.warn("CurrentTime exceeds duration (HLS loop detected), forcing stop and switching. Duration:", audio.duration, "Current:", audio.currentTime);
          // Dá»«ng HLS load
          if (hlsInstanceRef.current) {
            try {
              hlsInstanceRef.current.stopLoad();
              console.log("HLS load stopped (loop detected)");
            } catch (e) {
              console.warn("Failed to stop HLS load:", e);
            }
          }
          audio.pause();
          hasTriggeredEndedRef.current = true;
          if (repeatMode === "one") {
            hasTriggeredEndedRef.current = false;
            audio.currentTime = 0;
            if (hlsInstanceRef.current) {
              try {
                hlsInstanceRef.current.startLoad();
              } catch (e) {
                console.warn("Failed to restart HLS load:", e);
              }
            }
            audio.play().catch(err => console.error("Repeat play error:", err));
          } else {
            console.log("Auto-playing next song (loop detected), queue length:", queue.length);
            const finishedId = currentSong?.id;
            if (hasNextQueueSong()) {
              playNext();
              finalizeQueueAfterPlayback(finishedId);
            } else {
              finalizeQueueAfterPlayback(finishedId);
              if (!startSuggestionsPlayback()) {
                console.warn("No songs left to auto-play");
              }
            }
          }
        }
      }
    };

    // Chá»‰ add error listener cho Safari native HLS, KHÃ”NG add cho Hls.js
    // VÃ¬ Hls.js sáº½ tá»± xá»­ lÃ½ táº¥t cáº£ errors qua HLS.Events.ERROR
    // Náº¿u add error listener cho audio element khi dÃ¹ng Hls.js, nÃ³ sáº½ trigger
    // ngay cáº£ khi HLS Ä‘ang recover, gÃ¢y ra toast lá»—i khÃ´ng cáº§n thiáº¿t
    let handleError: ((e: Event) => void) | null = null;
    if (!Hls.isSupported() && audio.canPlayType("application/vnd.apple.mpegurl")) {
      handleError = (e: Event) => {
        const target = e.target as HTMLAudioElement;
        // Chá»‰ xá»­ lÃ½ lá»—i thá»±c sá»± fatal, khÃ´ng pháº£i recoverable errors
        if (target.error) {
          const errorCode = target.error.code;
          // MEDIA_ERR_ABORTED (1) vÃ  MEDIA_ERR_NETWORK (2) cÃ³ thá»ƒ recover
          // Chá»‰ xá»­ lÃ½ MEDIA_ERR_DECODE (3) vÃ  MEDIA_ERR_SRC_NOT_SUPPORTED (4)
          if (errorCode === MediaError.MEDIA_ERR_DECODE || 
              errorCode === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
            console.error("Fatal audio error:", e, "Code:", errorCode);
            toast({
              title: "Playback error",
              description: "Failed to play audio. Trying next song...",
              variant: "destructive",
            });
            // Try next song on fatal error
            setTimeout(() => handleNextClick(), 1000);
          } else {
            console.warn("Recoverable audio error (ignored):", errorCode);
          }
        }
      };
      audio.addEventListener("error", handleError);
      cleanupCallbacks.current.push(() => {
        if (handleError) {
          audio.removeEventListener("error", handleError);
        }
      });
    }

    audio.addEventListener("timeupdate", updateProgress);
    audio.addEventListener("loadedmetadata", handleDurationUpdate);
    audio.addEventListener("durationchange", handleDurationUpdate); // ThÃªm listener cho duration change
    audio.addEventListener("ended", handleEnded);
    // KHÃ”NG add error listener cho audio element khi dÃ¹ng Hls.js

    // Fallback check cho ended event (má»—i giÃ¢y)
    const endCheckInterval = setInterval(checkSongEnd, 1000);

    return () => {
      // Dá»«ng HLS trÆ°á»›c khi cleanup
      if (hlsInstanceRef.current) {
        try {
          hlsInstanceRef.current.stopLoad();
        } catch (e) {
          console.warn("Failed to stop HLS in cleanup:", e);
        }
      }
      
      audio.removeEventListener("timeupdate", updateProgress);
      audio.removeEventListener("loadedmetadata", handleDurationUpdate);
      audio.removeEventListener("durationchange", handleDurationUpdate);
      audio.removeEventListener("ended", handleEnded);
      if (handleError) {
        audio.removeEventListener("error", handleError);
      }
      clearInterval(endCheckInterval);
    };
  }, [repeatMode, playNext, hasNextQueueSong, startSuggestionsPlayback, finalizeQueueAfterPlayback, currentSong?.id]);

  // Handle volume
  useEffect(() => {
    if (!audioRef.current) return;
    audioRef.current.volume = isMuted ? 0 : volume[0] / 100;
  }, [volume, isMuted]);

  // Handle progress seek - cho phÃ©p Táº¤T Cáº¢ devices seek (ká»ƒ cáº£ non-active)
  // Non-active devices sáº½ gá»­i position lÃªn backend, active device sáº½ seek theo
  const handleProgressChange = (value: number[]) => {
    // DÃ¹ng duration tá»« context (Firebase) náº¿u cÃ³, fallback vá» audio.duration
    const effectiveDuration = duration > 0 
      ? duration / 1000 // Convert milliseconds to seconds
      : (audioRef.current?.duration && !isNaN(audioRef.current.duration) 
          ? audioRef.current.duration 
          : 0);
    
    if (effectiveDuration <= 0) return;

    setProgress(value);
    const newTime = (value[0] / 100) * effectiveDuration;
    const positionMs = Math.floor(newTime * 1000); // Convert to milliseconds

    if (!isNaN(newTime) && positionMs >= 0) {
      // Update local UI ngay láº­p tá»©c
      setCurrentTime(newTime);
      
      // Náº¿u lÃ  active device, seek audio ngay
      if (isThisDeviceActive && audioRef.current) {
        audioRef.current.currentTime = newTime;
      }
      
      // Táº¤T Cáº¢ devices (ká»ƒ cáº£ non-active) Ä‘á»u gá»­i position lÃªn backend
      // Backend sáº½ sync Firebase, active device sáº½ nháº­n vÃ  seek theo
      updatePosition(positionMs, duration > 0 ? duration : undefined).catch(err => {
        console.error('[MusicPlayer] Failed to sync position on seek:', err);
      });
    }
  };


  const toggleMute = () => setIsMuted(!isMuted);

  const handleShuffleToggle = () => {
    const newShuffleState = !isShuffled;
    toggleShuffle();
    // Auto táº¯t gá»£i Ã½ khi báº­t shuffle
    if (newShuffleState && autoPlaySuggestions) {
      setAutoPlaySuggestions(false);
    toast({
        title: "Shuffle on",
        description: "Gá»£i Ã½ tá»± Ä‘á»™ng Ä‘Ã£ táº¯t khi báº­t shuffle",
        duration: 2000,
      });
      return;
    }
    toast({
      title: newShuffleState ? "Shuffle on" : "Shuffle off",
      description: newShuffleState
        ? "Playing songs in random order"
        : "Playing songs in order",
      duration: 2000,
    });
  };

  const toggleLike = () => {
    setIsLiked(!isLiked);
    toast({
      title: isLiked ? "Removed from favorites" : "Added to favorites",
      duration: 2000,
    });
  };

  const handleShare = (type: string) => {
    if (!currentSong) return;

    switch (type) {
      case "friends":
        setShareSong({
          id: currentSong.id,
          title: currentSong.songName || currentSong.name || "Unknown Song",
          url: `${window.location.origin}/song/${currentSong.id}`,
        });
        break;
      case "playlist":
        setAddToPlaylistOpen(true);
        break;
      case "copy": {
        const songUrl = `${window.location.origin}/song/${currentSong.id}`;
        navigator.clipboard.writeText(songUrl);
        toast({
          title: "Link copied!",
          description: "Song link copied to clipboard",
        });
        break;
      }
    }
  };

  const cycleRepeat = () => {
    const modes: Array<"off" | "one" | "all"> = ["off", "one", "all"];
    const modeNames = ["Repeat off", "Repeat one", "Repeat all"];
    const currentIndex = modes.indexOf(repeatMode);
    const nextMode = modes[(currentIndex + 1) % modes.length];
    const nextModeName = modeNames[(currentIndex + 1) % modes.length];

    setRepeatMode(nextMode);
    // Auto táº¯t gá»£i Ã½ khi báº­t repeat (one hoáº·c all)
    if (nextMode !== "off" && autoPlaySuggestions) {
      setAutoPlaySuggestions(false);
    }
    toast({
      title: nextModeName,
      description:
        nextMode === "one" ? "Current song will repeat" :
          nextMode === "all" ? "All songs will repeat" :
            "Songs will play once",
      duration: 2000,
    });
  };

  // Hide player on login page or if no song is playing
  // Also reset showLyrics and isExpanded when no song
  useEffect(() => {
    if (!currentSong) {
      setShowLyrics(false);
      setIsExpanded(false);
      setShowPlaylist(false);
      setSuggestedSongs([]);
    }
  }, [currentSong]);

  // Close all overlays on Escape key (global handler)
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (isExpanded) {
          setIsExpanded(false);
          e.preventDefault();
          e.stopPropagation();
        } else if (showLyrics) {
          setShowLyrics(false);
          e.preventDefault();
          e.stopPropagation();
        } else if (showPlaylist) {
          setShowPlaylist(false);
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
    
    // Only add listener if any overlay is open
    if (isExpanded || showLyrics || showPlaylist) {
      window.addEventListener('keydown', handleEscape, true);
      return () => window.removeEventListener('keydown', handleEscape, true);
    }
  }, [isExpanded, showLyrics, showPlaylist]);

  // Safety: Force close all overlays if they're stuck open without currentSong
  useEffect(() => {
    if (!currentSong) {
      // Small delay to ensure state updates
      const timer = setTimeout(() => {
        if (isExpanded || showLyrics || showPlaylist) {
          console.warn("[MusicPlayer] Force closing stuck overlays - no current song");
          setIsExpanded(false);
          setShowLyrics(false);
          setShowPlaylist(false);
        }
      }, 100);
      return () => clearTimeout(timer);
    }
  }, [currentSong, isExpanded, showLyrics, showPlaylist]);

  // Load suggested songs (50 max) whenever current song changes
  useEffect(() => {
    if (!currentSong) {
      setSuggestedSongs([]);
      loadedSuggestionsForSongId.current = null;
      return;
    }

    const currentSongId = currentSong.id;
    if (loadedSuggestionsForSongId.current === currentSongId) {
      return;
    }

    let isMounted = true;
    const loadSuggestions = async () => {
      setIsLoadingSuggestions(true);
      try {
        const songId = typeof currentSongId === "string" ? Number(currentSongId) : currentSongId;
        const recommendations = await songsApi.getRecommendations(songId, 50);
        const formattedSongs = recommendations.map((s) => mapToPlayerSong(s));
        if (isMounted) {
          setSuggestedSongs(formattedSongs);
          loadedSuggestionsForSongId.current = currentSongId;
        }
      } catch (error) {
        console.error("Error loading suggestions:", error);
        if (isMounted) {
          setSuggestedSongs([]);
        }
      } finally {
        if (isMounted) {
          setIsLoadingSuggestions(false);
        }
      }
    };

    loadSuggestions();
    return () => {
      isMounted = false;
    };
  }, [currentSong?.id]);

  // Hide player if not authenticated or on login page
  if (location.pathname === "/login" || !isAuthenticated) {
    return null;
  }
  
  // Hide player if no song (but still authenticated)
  if (!currentSong) {
    return null;
  }

  return (
    <>
      {/* Audio Element */}
      <audio ref={audioRef} />

      {/* Mini Player */}
      <div className="fixed bottom-0 left-0 right-0 z-[55] bg-background/95 backdrop-blur-lg border-t border-border/40">
        <div className="container mx-auto px-2 sm:px-4 py-3">
          <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
            {/* Song Info */}
            {/* Song Info */}
            <div className="flex items-center space-x-3 flex-1 min-w-0 order-1 sm:order-none">
              <div
                className="relative group cursor-pointer"
                onClick={() => setShowLyrics(!showLyrics)}
              >
                <div className="w-10 h-10 sm:w-12 sm:h-12 rounded-full overflow-hidden shadow">
                  {currentSong.cover ? (
                    <img
                      src={currentSong.cover}
                      alt={currentSong.songName || currentSong.name || "Unknown Song"}
                      onError={handleImageError}
                      className={cn(
                        "w-full h-full object-cover transition-transform duration-300",
                        isPlaying && "spin-reverse-slower"
                      )}
                    />
                  ) : (
                    <div
                      className={cn(
                        "w-full h-full flex items-center justify-center bg-gradient-primary transition-transform duration-300",
                        isPlaying && "spin-reverse-slower"
                      )}
                    >
                      <Music className="w-5 h-5 text-white" />
                    </div>
                  )}
                </div>
              </div>

              <div className="min-w-0 flex-1">
                <h4 className="text-sm sm:text-base font-medium text-foreground truncate">
                  {currentSong.songName || currentSong.name || "Unknown Song"}
                </h4>
                <p className="text-xs sm:text-sm text-muted-foreground truncate">
                  {currentSong.artist || "Unknown Artist"}
                </p>
              </div>

              <Button
                variant="ghost"
                size="icon"
                className="h-7 w-7 sm:h-8 sm:w-8 shrink-0"
                onClick={toggleLike}
              >
                <Heart
                  className={cn(
                    "w-4 h-4",
                    isLiked && "fill-red-500 text-red-500"
                  )}
                />
              </Button>
            </div>


            {/* Player Controls */}
            <div className="flex flex-col items-center space-y-2 flex-1 max-w-md order-3 sm:order-none w-full sm:w-auto">
              <div className="flex items-center justify-center space-x-2 sm:space-x-3">
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={handleShuffleToggle}
                >
                  <Shuffle
                    className={cn("w-4 h-4", isShuffled && "text-primary")}
                  />
                </Button>

                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={() => {
                    console.log("Previous clicked, queue length:", queue.length, "currentSong:", currentSong?.id);
                    playPrevious();
                  }}
                  disabled={queue.length === 0}
                >
                  <SkipBack className="w-4 h-4" />
                </Button>

                <Button
                  variant="hero"
                  size="icon"
                  className="h-10 w-10 sm:h-12 sm:w-12"
                  onClick={togglePlay}
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <div className="w-5 h-5 sm:w-6 sm:h-6 border-2 border-white border-t-transparent rounded-full animate-spin" />
                  ) : isPlaying ? (
                    <Pause className="w-5 h-5 sm:w-6 sm:h-6" />
                  ) : (
                    <Play className="w-5 h-5 sm:w-6 sm:h-6" />
                  )}
                </Button>

                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={handleNextClick}
                  disabled={!hasNextQueueSong() && (!autoPlaySuggestions || suggestedSongs.length === 0)}
                >
                  <SkipForward className="w-4 h-4" />
                </Button>

                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={cycleRepeat}
                >
                  <Repeat
                    className={cn(
                      "w-4 h-4",
                      repeatMode !== "off" && "text-primary"
                    )}
                  />
                  {repeatMode === "one" && (
                    <span className="absolute text-xs font-bold text-primary">
                      1
                    </span>
                  )}
                </Button>
              </div>

              {/* Progress */}
              <div className="flex items-center space-x-2 w-full px-2 sm:px-0">
                <span className="text-xs text-muted-foreground w-8 text-right hidden sm:block">
                  {formatTime(getCurrentTime())}
                </span>
                <Slider
                  value={progress}
                  onValueChange={handleProgressChange}
                  max={100}
                  step={1}
                  className="flex-1"
                />
                <span className="text-xs text-muted-foreground w-8 hidden sm:block">
                  {formatTime(duration > 0 ? duration / 1000 : audioDuration)}
                </span>
              </div>
            </div>

            {/* Volume & Actions */}
            <div className="flex items-center space-x-2 flex-1 justify-end order-2 sm:order-none">
              {/* Device Status Indicator */}
              {activeDeviceName && (
                <Button
                  variant="ghost"
                  size="icon"
                  className={cn(
                    "h-8 w-8",
                    !isThisDeviceActive && "text-warning"
                  )}
                  onClick={() => setShowDeviceSelector(!showDeviceSelector)}
                  title={isThisDeviceActive ? `Äang phÃ¡t trÃªn: ${activeDeviceName}` : `Äang phÃ¡t trÃªn: ${activeDeviceName}. Báº¡n cÃ³ thá»ƒ Ä‘iá»u khiá»ƒn tá»« tab nÃ y, nhÆ°ng audio phÃ¡t á»Ÿ tab khÃ¡c. Click Ä‘á»ƒ chuyá»ƒn sang thiáº¿t bá»‹ nÃ y.`}
                >
                  <Users className="w-4 h-4" />
                </Button>
              )}
              
              {/* Playlist Menu Button */}
              <Button
                variant="ghost"
                size="icon"
                className="h-8 w-8"
                onClick={() => setShowPlaylist(!showPlaylist)}
              >
                <Menu className="w-4 h-4" />
              </Button>
              
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="icon" className="h-8 w-8">
                    <MoreHorizontal className="w-4 h-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-56">
                  <DropdownMenuItem onClick={() => handleShare("playlist")}>
                    <ListPlus className="w-4 h-4 mr-2" />
                    ThÃªm vÃ o playlist
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={() => handleShare("friends")}>
                    <Users className="w-4 h-4 mr-2" />
                    Chia sáº» vá»›i báº¡n bÃ¨
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={() => handleShare("copy")}>
                    <Copy className="w-4 h-4 mr-2" />
                    Copy link
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>

              <div className="hidden sm:flex items-center space-x-2">
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8"
                  onClick={toggleMute}
                >
                  {isMuted || volume[0] === 0 ? (
                    <VolumeX className="w-4 h-4" />
                  ) : (
                    <Volume2 className="w-4 h-4" />
                  )}
                </Button>
                <Slider
                  value={isMuted ? [0] : volume}
                  onValueChange={setVolume}
                  max={100}
                  step={1}
                  className="w-20"
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Expanded Player */}
      {isExpanded && (
        <div 
          className="fixed inset-0 z-[60] bg-background/95 backdrop-blur-lg flex flex-col"
          onKeyDown={(e) => {
            if (e.key === 'Escape') setIsExpanded(false);
          }}
        >
          {/* Header */}
          <div className="flex justify-between items-center p-4 border-b border-border/40">
            <h3 className="text-lg font-semibold">Now Playing</h3>
            <Button variant="ghost" size="icon" onClick={() => setIsExpanded(false)}>
              âœ•
            </Button>
          </div>

          {/* Content */}
          <div className="flex-1 flex flex-col items-center justify-center space-y-6 p-4 overflow-y-auto">
            {/* Cover */}
            <div className="w-64 h-64 rounded-full overflow-hidden shadow-lg">
              {currentSong.cover ? (
                <img
                  src={currentSong.cover}
                  alt={currentSong.songName || currentSong.name || "Unknown Song"}
                  onError={handleImageError}
                  className={cn(
                    "w-full h-full object-cover transition-transform duration-300",
                    isPlaying && "spin-reverse-slower"
                  )}
                />
              ) : (
                <div className={cn(
                  "w-full h-full flex items-center justify-center bg-gradient-primary transition-transform duration-300",
                  isPlaying && "spin-reverse-slower"
                )}>
                  <Music className="w-20 h-20 text-white" />
                </div>
              )}
            </div>

            {/* Info */}
            <div className="text-center space-y-1">
              <h2 className="text-2xl font-bold">{currentSong.songName || currentSong.name || "Unknown Song"}</h2>
              <p className="text-muted-foreground">{currentSong.artist || "Unknown Artist"}</p>
            </div>

            {/* Controls */}
            <div className="flex flex-col items-center space-y-4 w-full max-w-lg">
              <div className="flex items-center space-x-2 w-full px-4">
                <span className="text-xs text-muted-foreground">
                  {formatTime(getCurrentTime())}
                </span>
                <Slider
                  value={progress}
                  onValueChange={handleProgressChange}
                  max={100}
                  step={1}
                  className="flex-1"
                />
                <span className="text-xs text-muted-foreground">
                  {formatTime(duration > 0 ? duration / 1000 : audioDuration)}
                </span>
              </div>

              <div className="flex items-center justify-center space-x-4">
                <Button variant="ghost" size="icon" onClick={toggleShuffle}>
                  <Shuffle
                    className={cn("w-6 h-6", isShuffled && "text-primary")}
                  />
                </Button>
                <Button variant="ghost" size="icon" onClick={playPrevious}>
                  <SkipBack className="w-6 h-6" />
                </Button>
                <Button
                  variant="hero"
                  size="icon"
                  className="h-14 w-14"
                  onClick={togglePlay}
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <div className="w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin" />
                  ) : isPlaying ? (
                    <Pause className="w-6 h-6" />
                  ) : (
                    <Play className="w-6 h-6" />
                  )}
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handleNextClick}
                  disabled={!hasNextQueueSong() && (!autoPlaySuggestions || suggestedSongs.length === 0)}
                >
                  <SkipForward className="w-6 h-6" />
                </Button>
                <Button variant="ghost" size="icon" onClick={cycleRepeat}>
                  <Repeat
                    className={cn(
                      "w-6 h-6",
                      repeatMode !== "off" && "text-primary"
                    )}
                  />
                  {repeatMode === "one" && (
                    <span className="absolute text-xs font-bold text-primary">
                      1
                    </span>
                  )}
                </Button>
              </div>
            </div>

            {/* Lyrics in Expanded Player */}
            {showLyrics && lyrics.length > 0 && (
              <div className="w-full max-w-lg text-center mt-6 max-h-96 overflow-y-auto space-y-2">
                {lyrics.map((line, i) => (
                  <p
                    key={i}
                    className={cn(
                      "text-sm transition-colors cursor-pointer hover:text-primary",
                      i === currentLyricIndex
                        ? "text-primary font-medium text-lg"
                        : "text-muted-foreground"
                    )}
                    onClick={() => handleLyricClick(line.time)}
                    ref={i === currentLyricIndex ? currentLyricRef : null}
                  >
                    {line.text}
                  </p>
                ))}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Lyrics Panel */}
      {showLyrics && currentSong && (
        <div className="fixed inset-0 z-[52]">
          {/* Background overlay */}
          <div
            className="absolute inset-0 bg-gradient-to-b from-background/95 via-background/98 to-background backdrop-blur-md cursor-pointer"
            onClick={() => setShowLyrics(false)}
            onKeyDown={(e) => {
              if (e.key === 'Escape') setShowLyrics(false);
            }}
            role="button"
            tabIndex={0}
            aria-label="Close lyrics"
          />

          {/* Content panel */}
          <div className="relative h-full flex flex-col max-w-3xl mx-auto">
            {/* Header */}
            <div className="flex justify-between items-center p-4 sm:p-6 border-b border-border/40 bg-background/90 backdrop-blur-sm">
              <div>
                <h3 className="text-lg font-semibold">Lyrics</h3>
                <p className="text-sm text-muted-foreground">
                  {currentSong?.songName || currentSong?.name || "Unknown Song"} â€¢ {currentSong?.artist}
                </p>
              </div>
              <Button variant="ghost" size="icon" onClick={() => setShowLyrics(false)}>
                <X className="w-5 h-5" />
              </Button>
            </div>

            {/* Lyrics Content - Hidden scrollbar */}
            <div
              ref={lyricsRef}
              className="flex-1 overflow-y-auto px-4 sm:px-8 py-6 pb-24 space-y-2 sm:space-y-3 scrollbar-hide"
              style={{
                scrollbarWidth: 'none', /* Firefox */
                msOverflowStyle: 'none', /* IE and Edge */
              }}
            >
              <style>{`
                .scrollbar-hide::-webkit-scrollbar {
                  display: none; /* Chrome, Safari, Opera */
                }
              `}</style>
              {lyrics.map((line, i) => (
                <p
                  key={i}
                  className={cn(
                    "text-base sm:text-lg transition-all duration-300 cursor-pointer px-3 sm:px-4 py-2 sm:py-3 rounded-lg text-center select-none",
                    i === currentLyricIndex
                      ? "text-primary font-bold text-lg sm:text-2xl bg-primary/10 scale-105 shadow-lg"
                      : "text-muted-foreground hover:text-foreground hover:bg-muted/20"
                  )}
                  onClick={() => handleLyricClick(line.time)}
                  ref={i === currentLyricIndex ? currentLyricRef : null}
                >
                  {line.text}
                </p>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Playlist Panel */}
      {showPlaylist && (
        <div className="fixed inset-0 z-[52]">
          {/* Background overlay */}
          <div
            className="absolute inset-0 bg-background/95 backdrop-blur-md cursor-pointer"
            onClick={() => setShowPlaylist(false)}
            role="button"
            tabIndex={0}
            aria-label="Close playlist"
          />

          {/* Content panel */}
          <div className="relative h-full flex flex-col max-w-2xl mx-auto bg-background border-x border-border/40">
            {/* Header */}
            <div className="flex justify-between items-center p-4 sm:p-6 border-b border-border/40 bg-background/90 backdrop-blur-sm">
              <h3 className="text-lg font-semibold">Danh sÃ¡ch phÃ¡t</h3>
              <Button variant="ghost" size="icon" onClick={() => setShowPlaylist(false)}>
                <X className="w-5 h-5" />
              </Button>
            </div>

            {/* Playlist Content */}
            <div className="flex-1 overflow-y-auto p-4 space-y-8">
              <div>
                <div className="flex items-center justify-between mb-3">
                  <div>
                    <p className="text-sm text-muted-foreground">CÃ¡c bÃ i Ä‘ang á»Ÿ trong hÃ ng chá»</p>
                    <h4 className="text-lg font-semibold text-foreground">HÃ ng chá» hiá»‡n táº¡i ({queue.length})</h4>
                    <p className="text-[11px] text-muted-foreground/80 mt-1">
                      Giá»¯ biá»ƒu tÆ°á»£ng <GripVertical className="inline h-3 w-3" /> Ä‘á»ƒ sáº¯p xáº¿p. KÃ©o lÃªn/xuá»‘ng Ä‘á»ƒ xem thÃªm bÃ i hÃ¡t.
                    </p>
                  </div>
                </div>
                {queue.length === 0 ? (
                  <div className="flex flex-col items-center justify-center text-center py-12">
                    <Music className="w-12 h-12 text-muted-foreground mb-4" />
                    <p className="text-muted-foreground">Danh sÃ¡ch phÃ¡t trá»‘ng</p>
                    <p className="text-sm text-muted-foreground mt-2">
                      ThÃªm bÃ i hÃ¡t hoáº·c báº­t gá»£i Ã½ tá»± Ä‘á»™ng Ä‘á»ƒ tiáº¿p tá»¥c nghe nháº¡c
                    </p>
                  </div>
                ) : (
                  <div className="space-y-2">
                    {queue.map((song) => (
                      <div
                        key={song.id}
                        draggable
                        onDragStart={(event) => handleDragStart(event, song.id)}
                        onDragOver={(event) => handleDragOver(event, song.id)}
                        onDrop={(event) => handleDrop(event, song.id)}
                        onDragEnd={handleDragEnd}
                        onClick={() => playSong(song)}
                        className={cn(
                          "group flex items-center gap-3 rounded-xl border border-transparent bg-background/40 p-3 transition hover:border-primary/20 hover:bg-primary/5",
                          currentSong?.id === song.id && "border-primary/40 bg-primary/10",
                          draggingSongId === String(song.id) && "ring-2 ring-primary/50",
                        )}
                      >
                        <button
                          type="button"
                          onClick={(event) => event.stopPropagation()}
                          className="hidden cursor-grab rounded-md p-2 text-muted-foreground transition group-hover:flex group-active:cursor-grabbing"
                        >
                          <GripVertical className="h-4 w-4" />
                        </button>

                        <div className="relative w-12 h-12 rounded-md overflow-hidden flex-shrink-0 shadow-inner">
                          {song.cover ? (
                            <img
                              src={song.cover}
                              alt={song.songName || song.name || "Unknown Song"}
                              onError={handleImageError}
                              className="w-full h-full object-cover"
                            />
                          ) : (
                            <div className="w-full h-full flex items-center justify-center bg-gradient-primary">
                              <Music className="w-6 h-6 text-white" />
                            </div>
                          )}
                          {currentSong?.id === song.id && isPlaying && (
                            <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                              <div className="w-2 h-2 bg-white rounded-full animate-pulse" />
                            </div>
                          )}
                        </div>

                        <div className="flex-1 min-w-0">
                          <p
                            className={cn(
                              "text-sm font-semibold truncate",
                              currentSong?.id === song.id && "text-primary",
                            )}
                          >
                            {song.songName || song.name || "Unknown Song"}
                          </p>
                          <p className="text-xs text-muted-foreground truncate">
                            {song.artist || "Unknown Artist"}
                          </p>
                        </div>

                        <div className="flex items-center gap-2 text-xs text-muted-foreground flex-shrink-0">
                          <span>{formatTime(song.duration || 0)}</span>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="invisible text-muted-foreground transition group-hover:visible hover:text-destructive"
                            onClick={(event) => handleRemoveSong(event, song.id)}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                    ))}

                    {draggingSongId && (
                      <div
                        onDragOver={(event) => {
                          if (!draggingSongId) return;
                          event.preventDefault();
                        }}
                        onDrop={handleDropToEnd}
                        className="flex h-12 items-center justify-center rounded-xl border border-dashed border-muted-foreground/40 text-xs text-muted-foreground"
                      >
                        Tháº£ vÃ o Ä‘Ã¢y Ä‘á»ƒ Ä‘Æ°a bÃ i xuá»‘ng cuá»‘i danh sÃ¡ch
                      </div>
                    )}
                  </div>
                )}

                {showQueueScrollHint && (
                  <div className="mt-4 flex items-center justify-center gap-2 text-xs text-muted-foreground">
                    <ChevronsDown className="h-4 w-4 animate-bounce" />
                    Cuá»™n Ä‘á»ƒ xem thÃªm bÃ i hÃ¡t
                  </div>
                )}
            </div>

              <div>
                <div className="flex items-center justify-between mb-3">
                  <div>
                    <h4 className="text-lg font-bold text-foreground">
                      Tá»± Ä‘á»™ng phÃ¡t
                    </h4>
                    <p className="text-sm text-muted-foreground">
                      Danh sÃ¡ch bÃ i hÃ¡t gá»£i Ã½
                    </p>
                  </div>
                  <Switch
                    id="auto-suggestions-switch"
                    checked={autoPlaySuggestions}
                    onCheckedChange={handleToggleAutoSuggestions}
                    disabled={repeatMode !== "off"}
                  />
                </div>
                {repeatMode !== "off" && (
                  <p className="text-xs text-muted-foreground -mt-2 mb-3">
                    Táº¯t cháº¿ Ä‘á»™ láº·p Ä‘á»ƒ sá»­ dá»¥ng gá»£i Ã½ tá»± Ä‘á»™ng.
                  </p>
                )}

                {!autoPlaySuggestions ? null : isLoadingSuggestions ? (
                  <div className="flex flex-col items-center justify-center text-center py-12">
                    <div className="w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin mb-4" />
                    <p className="text-muted-foreground">Äang táº£i gá»£i Ã½...</p>
                  </div>
                ) : suggestedSongs.length === 0 ? (
                  <div className="flex flex-col items-center justify-center text-center py-12">
                    <Music className="w-12 h-12 text-muted-foreground mb-4" />
                    <p className="text-muted-foreground">KhÃ´ng cÃ³ gá»£i Ã½ phÃ¹ há»£p</p>
                    <p className="text-sm text-muted-foreground mt-2">
                      Thá»­ chá»n bÃ i hÃ¡t khÃ¡c Ä‘á»ƒ há»‡ thá»‘ng phÃ¢n tÃ­ch láº¡i
                    </p>
                  </div>
                ) : (
                  suggestedSongs
                    .filter(song => !queue.some(q => q.id === song.id))
                    .slice(0, 50)
                    .map((song) => (
                    <div
                      key={song.id}
                      onClick={() => {
                        // Khi click vÃ o bÃ i gá»£i Ã½, thÃªm vÃ o queue vÃ  phÃ¡t (khÃ´ng Ä‘Ã³ng panel)
                        addToQueue(song);
                        playSong(song);
                      }}
                      className={cn(
                        "flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors hover:bg-accent",
                        currentSong?.id === song.id && "bg-primary/10 border border-primary/20"
                      )}
                    >
                      <div className="relative w-12 h-12 rounded-md overflow-hidden flex-shrink-0">
                        {song.cover ? (
                          <img
                            src={song.cover}
                            alt={song.songName || song.name || "Unknown Song"}
                            onError={handleImageError}
                            className="w-full h-full object-cover"
                          />
                        ) : (
                          <div className="w-full h-full flex items-center justify-center bg-gradient-primary">
                            <Music className="w-6 h-6 text-white" />
                          </div>
                        )}
                        {currentSong?.id === song.id && isPlaying && (
                          <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                            <div className="w-2 h-2 bg-white rounded-full animate-pulse" />
                          </div>
                        )}
                      </div>
                      <div className="flex-1 min-w-0">
                        <p
                          className={cn(
                            "text-sm font-medium truncate",
                            currentSong?.id === song.id && "text-primary"
                          )}
                        >
                          {song.songName || song.name || "Unknown Song"}
                        </p>
                        <p className="text-xs text-muted-foreground truncate">
                          {typeof song.artist === "string" ? song.artist : song.artist || "Unknown Artist"}
                        </p>
                      </div>
                      <div className="text-xs text-muted-foreground flex-shrink-0">
                        {formatTime(song.duration || 0)}
                      </div>
                    </div>
                  ))
                )}
                </div>
            </div>
          </div>
        </div>
      )}
      
      {currentSong && (
        <>
          <AddToPlaylistDialog
            open={addToPlaylistOpen}
            onOpenChange={setAddToPlaylistOpen}
            songId={currentSong.id}
            songTitle={currentSong.songName || currentSong.name || "Unknown Song"}
            songCover={currentSong.cover}
          />
          {shareSong && (
            <ShareButton
              key={`share-${shareSong.id}`}
              title={shareSong.title}
              type="song"
              url={shareSong.url}
              open={!!shareSong}
              onOpenChange={(isOpen) => {
                if (!isOpen) {
                  setShareSong(null);
                }
              }}
            />
          )}
        </>
      )}
      
      {/* Device Selector Dialog */}
      {showDeviceSelector && (
        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-background/95 backdrop-blur-lg">
          <div className="bg-background border border-border rounded-lg p-6 max-w-md w-full mx-4">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold">Thiáº¿t bá»‹ phÃ¡t nháº¡c</h3>
              <Button
                variant="ghost"
                size="icon"
                onClick={() => setShowDeviceSelector(false)}
              >
                <X className="w-5 h-5" />
              </Button>
            </div>
            <div className="space-y-2">
              {activeDeviceName ? (
                <div
                  className={cn(
                    "flex items-center justify-between p-3 rounded-lg border transition-colors",
                    isThisDeviceActive
                      ? "border-primary bg-primary/10"
                      : "border-border"
                  )}
                >
                  <div className="flex items-center space-x-3">
                    <div className={cn(
                      "w-3 h-3 rounded-full",
                      isThisDeviceActive ? "bg-primary" : "bg-muted-foreground"
                    )} />
                    <div>
                      <p className="font-medium">{activeDeviceName}</p>
                      {isThisDeviceActive ? (
                        <p className="text-xs text-muted-foreground">Äang phÃ¡t audio</p>
                      ) : (
                        <p className="text-xs text-muted-foreground">CÃ³ thá»ƒ Ä‘iá»u khiá»ƒn, nhÆ°ng audio phÃ¡t á»Ÿ tab khÃ¡c</p>
                      )}
                    </div>
                  </div>
                  {isThisDeviceActive && (
                    <div className="w-2 h-2 bg-primary rounded-full animate-pulse" />
                  )}
                </div>
              ) : (
                <p className="text-sm text-muted-foreground">ChÆ°a cÃ³ thiáº¿t bá»‹ nÃ o Ä‘ang phÃ¡t nháº¡c</p>
              )}
              
              {!isThisDeviceActive && (
                <Button
                  className="w-full mt-4"
                  onClick={async () => {
                    await requestPlaybackControl();
                    setShowDeviceSelector(false);
                  }}
                >
                  Chuyá»ƒn phÃ¡t nháº¡c sang thiáº¿t bá»‹ nÃ y
                </Button>
              )}
            </div>
            <p className="text-xs text-muted-foreground mt-4">
              Chá»‰ má»™t thiáº¿t bá»‹ cÃ³ thá»ƒ phÃ¡t nháº¡c táº¡i má»™t thá»i Ä‘iá»ƒm.
            </p>
          </div>
        </div>
      )}
    </>
  );
};

export default MusicPlayer;
